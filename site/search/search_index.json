{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QtPlugin Documentation\ud83d\udd0c QtPlugin","text":"<p>Modern C++ Plugin System for Qt Applications</p> <p> </p>"},{"location":"#what-is-qtplugin","title":"\ud83c\udfaf What is QtPlugin?","text":"<p>QtPlugin is a modern, enterprise-grade C++ plugin system built on Qt 6 that enables dynamic plugin loading and management in Qt applications. Unlike traditional Qt plugin systems, QtPlugin is designed to work in pure C++ environments without QML dependencies, making it suitable for a wide range of applications.</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li>\ud83d\ude80 Pure C++ Implementation - No QML dependencies, works in any C++ application</li> <li>\ud83d\udd27 Modern C++ Standards - Leverages C++17/20/23 features including concepts, coroutines, and <code>std::expected</code></li> <li>\ud83d\udee1\ufe0f Type Safety - Compile-time validation using C++20 concepts</li> <li>\ud83d\udce6 Minimal Dependencies - Core library depends only on Qt6::Core</li> <li>\ud83c\udfd7\ufe0f Modular Design - Optional components for network, UI, and security features</li> <li>\ud83d\udd12 Thread Safety - Safe concurrent plugin operations</li> <li>\ud83d\udd04 Hot Reloading - Dynamic plugin reloading during runtime</li> <li>\ud83d\udcca Version Management - Multi-version plugin support with migration and rollback</li> <li>\ud83d\udee1\ufe0f Security - Plugin validation and sandboxing capabilities</li> <li>\u26a1 Performance - Efficient loading and communication mechanisms</li> </ul>"},{"location":"#production-ready","title":"\ud83c\udf89 Production Ready","text":"<p>Latest Status: All core libraries and comprehensive test suites are building and passing successfully!</p> <ul> <li>\u2705 Core Library: <code>libqtplugin-core.a</code> - Complete implementation</li> <li>\u2705 Security Module: <code>libqtplugin-security.a</code> - Full security features  </li> <li>\u2705 Example Plugins - Working demonstration plugins</li> <li>\u2705 Test Results: 181/181 PASSING (100% success rate)</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#installation","title":"Installation","text":"CMake FetchContentfind_packagevcpkg <pre><code>include(FetchContent)\nFetchContent_Declare(\n    QtPlugin\n    GIT_REPOSITORY https://github.com/QtForge/QtPlugin.git\n    GIT_TAG        v3.0.0\n)\nFetchContent_MakeAvailable(QtPlugin)\n\ntarget_link_libraries(your_app QtPlugin::Core)\n</code></pre> <pre><code>find_package(QtPlugin REQUIRED COMPONENTS Core Security)\ntarget_link_libraries(your_app QtPlugin::Core QtPlugin::Security)\n</code></pre> <pre><code>vcpkg install qtplugin\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>#include &lt;qtplugin/qtplugin.hpp&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Initialize the library\n    qtplugin::LibraryInitializer init;\n    if (!init.is_initialized()) {\n        std::cerr &lt;&lt; \"Failed to initialize QtPlugin library\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // Create plugin manager\n    qtplugin::PluginManager manager;\n\n    // Load a plugin\n    auto result = manager.load_plugin(\"./plugins/example_plugin.so\");\n    if (!result) {\n        std::cerr &lt;&lt; \"Failed to load plugin: \" &lt;&lt; result.error().message &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // Get the loaded plugin\n    auto plugin = manager.get_plugin(result.value());\n    if (plugin) {\n        std::cout &lt;&lt; \"Loaded plugin: \" &lt;&lt; plugin-&gt;name() &lt;&lt; std::endl;\n\n        // Initialize the plugin\n        auto init_result = plugin-&gt;initialize();\n        if (init_result) {\n            std::cout &lt;&lt; \"Plugin initialized successfully\" &lt;&lt; std::endl;\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"#documentation-structure","title":"\ud83d\udcda Documentation Structure","text":""},{"location":"#for-new-users","title":"\ud83c\udfaf For New Users","text":"<ul> <li> <p> Getting Started</p> <p>Learn the basics and get QtPlugin up and running quickly</p> <p> Start here</p> </li> <li> <p> User Guide</p> <p>Comprehensive guides for using QtPlugin in your applications</p> <p> User Guide</p> </li> </ul>"},{"location":"#for-developers","title":"\ud83d\udee0\ufe0f For Developers","text":"<ul> <li> <p> Developer Guide</p> <p>Step-by-step guides for creating plugins and advanced usage</p> <p> Developer Guide</p> </li> <li> <p> API Reference</p> <p>Complete API documentation with examples and cross-references</p> <p> API Reference</p> </li> </ul>"},{"location":"#for-contributors","title":"\ud83c\udfd7\ufe0f For Contributors","text":"<ul> <li> <p> Contributing</p> <p>Guidelines for contributing to the QtPlugin project</p> <p> Contributing</p> </li> <li> <p>:material-architecture: Architecture</p> <p>Deep dive into system design and architectural patterns</p> <p> Architecture</p> </li> </ul>"},{"location":"#why-choose-qtplugin","title":"\ud83c\udfc6 Why Choose QtPlugin?","text":""},{"location":"#modern-c-excellence","title":"\ud83d\udd25 Modern C++ Excellence","text":"<p>QtPlugin showcases modern C++20 engineering practices:</p> <ul> <li>Custom <code>expected&lt;T,E&gt;</code> for C++20 compatibility</li> <li>RAII for automatic resource management</li> <li>Thread-safe operations with proper synchronization</li> <li>Type-safe APIs with compile-time validation</li> </ul>"},{"location":"#enterprise-grade-security","title":"\ud83d\udee1\ufe0f Enterprise-Grade Security","text":"<ul> <li>Multi-layer validation (file, signature, runtime)</li> <li>Trust management with publisher reputation</li> <li>Capability-based security with permission system</li> <li>Configurable security levels from none to maximum</li> </ul>"},{"location":"#high-performance","title":"\u26a1 High Performance","text":"<ul> <li>Plugin loading: 1.2ms average</li> <li>Command execution: 0.05ms average  </li> <li>Memory usage: 2.1MB per plugin</li> <li>Concurrent operations: 1000+ ops/sec</li> </ul>"},{"location":"#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>QtPlugin is perfect for:</p> <ul> <li>Desktop Applications requiring extensibility</li> <li>Development Tools with plugin ecosystems</li> <li>Enterprise Software needing modular architecture</li> <li>Game Engines with scripting capabilities</li> <li>Scientific Applications with custom analysis modules</li> <li>Media Processing tools with filter plugins</li> </ul>"},{"location":"#community-support","title":"\ud83e\udd1d Community &amp; Support","text":"<ul> <li>\ud83d\udcd6 Documentation: Comprehensive guides and API reference</li> <li>\ud83d\udc1b Issues: GitHub Issues for bug reports</li> <li>\ud83d\udcac Discussions: GitHub Discussions for questions</li> <li>\ud83d\udd04 Contributing: Contributing Guide for contributors</li> </ul>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>QtPlugin is licensed under the MIT License. See License for details.</p> <p>Ready to get started?</p> <p> Get Started View Examples </p>"},{"location":"DEVELOPMENT/","title":"Development Guide","text":""},{"location":"DEVELOPMENT/#prerequisites","title":"Prerequisites","text":"<ul> <li>Qt 6.0+ (Core required; Network/Widgets optional)</li> <li>CMake 3.21+</li> <li>C++20 compiler</li> </ul>"},{"location":"DEVELOPMENT/#build","title":"Build","text":"<pre><code>mkdir build &amp;&amp; cd build\ncmake .. -DQTPLUGIN_BUILD_TESTS=ON -DCMAKE_BUILD_TYPE=Debug\ncmake --build . -j\nctest --output-on-failure\n</code></pre>"},{"location":"DEVELOPMENT/#coding-standards","title":"Coding Standards","text":"<ul> <li>Modern C++20, RAII, expected <li>Thread safety with std::mutex/shared_mutex</li> <li>Public API documented with Doxygen-style comments</li>"},{"location":"DEVELOPMENT/#formatting","title":"Formatting","text":"<ul> <li>Configure your editor to use the repo .clang-format</li> <li>To format: find . -regex \"..[ch]pp\" -o -name \".c\" -o -name \"*.h\" | xargs clang-format -i</li> </ul>"},{"location":"DEVELOPMENT/#documentation","title":"Documentation","text":"<ul> <li>Generate API docs with: doxygen Doxyfile (outputs to docs/doxygen)</li> </ul>"},{"location":"DEVELOPMENT/#pre-commit","title":"Pre-commit","text":"<ul> <li>Run clang-format</li> <li>Build and run tests</li> <li>Update docs and CHANGELOG</li> </ul>"},{"location":"MIGRATION/","title":"Migration Guide","text":""},{"location":"MIGRATION/#upgrading-to-300","title":"Upgrading to 3.0.0","text":""},{"location":"MIGRATION/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Public API remains backward compatible for most use cases. Review the new component-based architecture for advanced customization.</li> </ul>"},{"location":"MIGRATION/#recommended-actions","title":"Recommended Actions","text":"<ul> <li>Audit includes: prefer including  rather than individual headers unless you need specific components. <li>Review security configuration defaults. The default SecurityLevel is Medium.</li>"},{"location":"MIGRATION/#from-2x-to-30","title":"From 2.x to 3.0","text":"<ul> <li>Replace direct PluginManager construction with the new builder if you need fine-grained component selection.</li> </ul>"},{"location":"MIGRATION/#deprecations","title":"Deprecations","text":"<ul> <li>Some platform-specific helpers are temporarily disabled behind build flags. See CMake options.</li> </ul>"},{"location":"SECURITY/","title":"Security Policy","text":""},{"location":"SECURITY/#supported-versions","title":"Supported Versions","text":"<ul> <li>3.x: Fully supported</li> <li>2.x: Security fixes only</li> <li>1.x: End of life</li> </ul>"},{"location":"SECURITY/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>Please report security issues by creating a confidential security advisory on GitHub or contacting the maintainers via a private channel. We will acknowledge receipt within 72 hours and keep you informed of the fix progress.</p>"},{"location":"SECURITY/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Use the highest feasible SecurityLevel in production</li> <li>Prefer signed plugins from trusted publishers</li> <li>Keep Qt and dependencies up to date</li> </ul>"},{"location":"version_management/","title":"Plugin Version Management","text":"<p>QtForge 3.1.0 introduces comprehensive plugin version management capabilities, allowing applications to install, manage, and migrate between different versions of plugins seamlessly.</p>"},{"location":"version_management/#overview","title":"Overview","text":"<p>The version management system provides:</p> <ul> <li>Multi-version Support: Install and maintain multiple versions of the same plugin</li> <li>Version Migration: Automatic and custom data migration between plugin versions</li> <li>Rollback Capabilities: Create backups and rollback to previous versions</li> <li>Compatibility Management: Check and enforce version compatibility</li> <li>Storage Management: Efficient storage and cleanup of plugin versions</li> </ul>"},{"location":"version_management/#key-components","title":"Key Components","text":""},{"location":"version_management/#ipluginversionmanager","title":"IPluginVersionManager","text":"<p>The main interface for version management operations:</p> <pre><code>#include \"qtplugin/managers/plugin_version_manager.hpp\"\n\n// Create version manager\nauto version_manager = create_plugin_version_manager(\n    registry, config_manager, logger);\n</code></pre>"},{"location":"version_management/#version-class","title":"Version Class","text":"<p>Represents semantic versions (major.minor.patch):</p> <pre><code>#include \"qtplugin/utils/version.hpp\"\n\nVersion v1(1, 0, 0);        // 1.0.0\nVersion v2(1, 2, 3);        // 1.2.3\nVersion v3(2, 0, 0, \"beta\"); // 2.0.0-beta\n</code></pre>"},{"location":"version_management/#basic-usage","title":"Basic Usage","text":""},{"location":"version_management/#installing-plugin-versions","title":"Installing Plugin Versions","text":"<pre><code>// Install a specific version\nauto result = version_manager-&gt;install_version(\n    \"my.plugin\", Version(1, 2, 0), \"/path/to/plugin.dll\");\n\nif (result) {\n    std::cout &lt;&lt; \"Plugin installed successfully\" &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"Installation failed: \" &lt;&lt; result.error().message &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"version_management/#managing-active-versions","title":"Managing Active Versions","text":"<pre><code>// Set active version\nauto activate_result = version_manager-&gt;set_active_version(\n    \"my.plugin\", Version(1, 2, 0), true); // true = migrate data\n\n// Get active version\nauto active_version = version_manager-&gt;get_active_version(\"my.plugin\");\nif (active_version) {\n    std::cout &lt;&lt; \"Active version: \" &lt;&lt; active_version-&gt;version.to_string() &lt;&lt; std::endl;\n}\n\n// List all installed versions\nauto versions = version_manager-&gt;get_installed_versions(\"my.plugin\");\nfor (const auto&amp; version_info : versions) {\n    std::cout &lt;&lt; \"Version: \" &lt;&lt; version_info.version.to_string()\n              &lt;&lt; \" Status: \" &lt;&lt; static_cast&lt;int&gt;(version_info.status) &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"version_management/#version-migration","title":"Version Migration","text":""},{"location":"version_management/#automatic-migration","title":"Automatic Migration","text":"<p>The system automatically handles migration for compatible version changes:</p> <pre><code>// Minor and patch version changes are automatically migrated\nauto result = version_manager-&gt;set_active_version(\n    \"my.plugin\", Version(1, 2, 1), true); // Automatic migration\n</code></pre>"},{"location":"version_management/#custom-migration","title":"Custom Migration","text":"<p>Register custom migration logic for complex version changes:</p> <pre><code>// Register custom migration\nauto migration_result = version_manager-&gt;register_migration(\n    \"my.plugin\", \n    Version(1, 0, 0),  // from version\n    Version(2, 0, 0),  // to version\n    [](const MigrationContext&amp; context) -&gt; qtplugin::expected&lt;void, PluginError&gt; {\n        // Custom migration logic\n        std::cout &lt;&lt; \"Migrating from \" &lt;&lt; context.from_version.to_string()\n                  &lt;&lt; \" to \" &lt;&lt; context.to_version.to_string() &lt;&lt; std::endl;\n\n        // Perform migration tasks\n        // - Convert configuration files\n        // - Update data structures\n        // - Migrate user preferences\n\n        return {}; // Success\n    });\n</code></pre>"},{"location":"version_management/#migration-context","title":"Migration Context","text":"<p>The <code>MigrationContext</code> provides information and control over the migration process:</p> <pre><code>struct MigrationContext {\n    std::string plugin_id;              // Plugin being migrated\n    Version from_version;               // Source version\n    Version to_version;                 // Target version\n    MigrationStrategy strategy;         // Migration strategy\n    std::filesystem::path data_directory; // Plugin data directory\n    QJsonObject old_configuration;     // Old configuration\n    QJsonObject new_configuration;     // New configuration\n    bool preserve_user_data;           // Whether to preserve user data\n    bool create_backup;                // Whether to create backup\n};\n</code></pre>"},{"location":"version_management/#rollback-and-backup","title":"Rollback and Backup","text":""},{"location":"version_management/#creating-backups","title":"Creating Backups","text":"<pre><code>// Create backup before major changes\nauto backup_result = version_manager-&gt;create_backup(\"my.plugin\", Version(1, 2, 0));\nif (backup_result) {\n    std::cout &lt;&lt; \"Backup created at: \" &lt;&lt; backup_result-&gt;backup_path.string() &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"version_management/#rolling-back","title":"Rolling Back","text":"<pre><code>// Rollback to previous version\nauto rollback_result = version_manager-&gt;rollback_to_version(\n    \"my.plugin\", Version(1, 1, 0), true); // true = preserve user data\n\nif (rollback_result) {\n    std::cout &lt;&lt; \"Rollback successful\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"version_management/#managing-rollback-points","title":"Managing Rollback Points","text":"<pre><code>// Get available rollback points\nauto rollback_points = version_manager-&gt;get_rollback_points(\"my.plugin\");\nfor (const auto&amp; point : rollback_points) {\n    std::cout &lt;&lt; \"Rollback point: v\" &lt;&lt; point.current_version.to_string()\n              &lt;&lt; \" (created: \" &lt;&lt; /* format timestamp */ \")\" &lt;&lt; std::endl;\n}\n\n// Clean up old backups (keep only 5 most recent)\nint cleaned = version_manager-&gt;cleanup_old_backups(\"my.plugin\", 5);\nstd::cout &lt;&lt; \"Cleaned up \" &lt;&lt; cleaned &lt;&lt; \" old backups\" &lt;&lt; std::endl;\n</code></pre>"},{"location":"version_management/#compatibility-management","title":"Compatibility Management","text":""},{"location":"version_management/#checking-compatibility","title":"Checking Compatibility","text":"<pre><code>// Check compatibility between plugin and host versions\nauto compatibility = version_manager-&gt;check_compatibility(\n    \"my.plugin\", Version(1, 5, 0), Version(1, 0, 0)); // plugin vs host\n\nswitch (compatibility) {\n    case CompatibilityLevel::Breaking:\n        std::cout &lt;&lt; \"Breaking changes - manual migration required\" &lt;&lt; std::endl;\n        break;\n    case CompatibilityLevel::Major:\n        std::cout &lt;&lt; \"Major changes - automatic migration possible\" &lt;&lt; std::endl;\n        break;\n    case CompatibilityLevel::Minor:\n        std::cout &lt;&lt; \"Minor changes - backward compatible\" &lt;&lt; std::endl;\n        break;\n    case CompatibilityLevel::Patch:\n        std::cout &lt;&lt; \"Patch changes - fully compatible\" &lt;&lt; std::endl;\n        break;\n    case CompatibilityLevel::Build:\n        std::cout &lt;&lt; \"Build changes - no migration needed\" &lt;&lt; std::endl;\n        break;\n}\n</code></pre>"},{"location":"version_management/#getting-compatible-versions","title":"Getting Compatible Versions","text":"<pre><code>// Get all versions compatible with host version\nauto compatible_versions = version_manager-&gt;get_compatible_versions(\n    \"my.plugin\", Version(1, 0, 0)); // host version\n\nfor (const auto&amp; version : compatible_versions) {\n    std::cout &lt;&lt; \"Compatible version: \" &lt;&lt; version.to_string() &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"version_management/#storage-management","title":"Storage Management","text":""},{"location":"version_management/#storage-configuration","title":"Storage Configuration","text":"<pre><code>// Set custom storage directory\nauto result = version_manager-&gt;set_storage_directory(\"/custom/plugin/storage\");\n\n// Get current storage directory\nauto storage_dir = version_manager-&gt;get_storage_directory();\nstd::cout &lt;&lt; \"Storage directory: \" &lt;&lt; storage_dir.string() &lt;&lt; std::endl;\n</code></pre>"},{"location":"version_management/#storage-cleanup","title":"Storage Cleanup","text":"<pre><code>// Clean up unused versions (keep only 3 most recent)\nint cleaned_versions = version_manager-&gt;cleanup_unused_versions(\"my.plugin\", 3);\n\n// Get storage usage information\nauto usage = version_manager-&gt;get_storage_usage(\"my.plugin\");\nstd::cout &lt;&lt; \"Storage usage: \" &lt;&lt; usage[\"total_size\"].toVariant().toLongLong() \n          &lt;&lt; \" bytes\" &lt;&lt; std::endl;\n</code></pre>"},{"location":"version_management/#event-handling","title":"Event Handling","text":""},{"location":"version_management/#version-events","title":"Version Events","text":"<pre><code>// Register for version events\nauto subscription_id = version_manager-&gt;register_version_event_callback(\n    [](const std::string&amp; plugin_id, const Version&amp; version, VersionInstallStatus status) {\n        std::cout &lt;&lt; \"Plugin \" &lt;&lt; plugin_id &lt;&lt; \" v\" &lt;&lt; version.to_string()\n                  &lt;&lt; \" status changed to \" &lt;&lt; static_cast&lt;int&gt;(status) &lt;&lt; std::endl;\n    });\n\n// Unregister when done\nversion_manager-&gt;unregister_version_event_callback(subscription_id);\n</code></pre>"},{"location":"version_management/#statistics-and-monitoring","title":"Statistics and Monitoring","text":""},{"location":"version_management/#version-statistics","title":"Version Statistics","text":"<pre><code>// Get overall version management statistics\nauto stats = version_manager-&gt;get_version_statistics();\n\nstd::cout &lt;&lt; \"Total plugins: \" &lt;&lt; stats[\"total_plugins\"].toInt() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Total versions: \" &lt;&lt; stats[\"total_versions\"].toInt() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Active versions: \" &lt;&lt; stats[\"active_versions\"].toInt() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Storage usage: \" &lt;&lt; stats[\"storage_size_bytes\"].toVariant().toLongLong() \n          &lt;&lt; \" bytes\" &lt;&lt; std::endl;\n</code></pre>"},{"location":"version_management/#integration-with-pluginmanager","title":"Integration with PluginManager","text":"<p>The version management system is fully integrated with the main <code>PluginManager</code>:</p> <pre><code>#include \"qtplugin/core/plugin_manager.hpp\"\n\n// Create plugin manager (includes version management)\nauto plugin_manager = std::make_unique&lt;PluginManager&gt;();\n\n// Access version management through plugin manager\nauto&amp; version_manager = plugin_manager-&gt;version_manager();\n\n// Or use plugin manager's version management methods directly\nauto result = plugin_manager-&gt;install_plugin_version(\n    \"my.plugin\", Version(1, 2, 0), \"/path/to/plugin.dll\");\n</code></pre>"},{"location":"version_management/#best-practices","title":"Best Practices","text":"<ol> <li>Always create backups before major version upgrades</li> <li>Test migrations in a development environment first</li> <li>Use semantic versioning for your plugins</li> <li>Register custom migrations for breaking changes</li> <li>Clean up old versions regularly to save storage space</li> <li>Monitor version events for debugging and logging</li> <li>Check compatibility before installing new versions</li> </ol>"},{"location":"version_management/#error-handling","title":"Error Handling","text":"<p>All version management operations return <code>qtplugin::expected&lt;T, VersionError&gt;</code> for robust error handling:</p> <pre><code>auto result = version_manager-&gt;install_version(\"my.plugin\", version, path);\nif (!result) {\n    switch (result.error().code) {\n        case VersionErrorCode::VersionAlreadyExists:\n            std::cout &lt;&lt; \"Version already installed\" &lt;&lt; std::endl;\n            break;\n        case VersionErrorCode::StorageError:\n            std::cout &lt;&lt; \"Storage error: \" &lt;&lt; result.error().message &lt;&lt; std::endl;\n            break;\n        case VersionErrorCode::MigrationFailed:\n            std::cout &lt;&lt; \"Migration failed: \" &lt;&lt; result.error().message &lt;&lt; std::endl;\n            break;\n        // Handle other error codes...\n    }\n}\n</code></pre>"},{"location":"version_management/#see-also","title":"See Also","text":"<ul> <li>Plugin Development Guide</li> <li>API Reference</li> <li>Examples</li> <li>Testing Guide</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Welcome to the comprehensive QtPlugin API reference. This documentation covers all public APIs, classes, and functions available in the QtPlugin library.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>QtPlugin provides a modern, type-safe C++ plugin system with the following key components:</p> <ul> <li>Core: Essential plugin management functionality</li> <li>Communication: Inter-plugin messaging and events</li> <li>Security: Plugin validation and trust management</li> <li>Utils: Helper classes and error handling</li> <li>Optional Components: Network and UI extensions</li> </ul>"},{"location":"api/#quick-reference","title":"Quick Reference","text":""},{"location":"api/#essential-classes","title":"Essential Classes","text":"Class Purpose Header <code>IPlugin</code> Base plugin interface <code>qtplugin/core/plugin_interface.hpp</code> <code>PluginManager</code> Central plugin management <code>qtplugin/core/plugin_manager.hpp</code> <code>PluginLoader</code> Dynamic plugin loading <code>qtplugin/core/plugin_loader.hpp</code> <code>MessageBus</code> Inter-plugin communication <code>qtplugin/communication/message_bus.hpp</code> <code>SecurityManager</code> Plugin security <code>qtplugin/security/security_manager.hpp</code>"},{"location":"api/#key-types","title":"Key Types","text":"Type Description Header <code>expected&lt;T, E&gt;</code> Error handling type <code>qtplugin/utils/error_handling.hpp</code> <code>PluginError</code> Plugin error information <code>qtplugin/utils/error_handling.hpp</code> <code>PluginMetadata</code> Plugin metadata structure <code>qtplugin/core/plugin_interface.hpp</code> <code>Version</code> Version information <code>qtplugin/utils/version.hpp</code>"},{"location":"api/#core-components","title":"Core Components","text":""},{"location":"api/#plugin-system","title":"Plugin System","text":"<p>The core plugin system provides the fundamental functionality for plugin management:</p> <ul> <li> <p> Plugin Interface</p> <p>Base interface that all plugins must implement</p> <p>Key Features: - Lifecycle management (initialize, shutdown) - Metadata and identification - Command execution - Configuration management</p> </li> <li> <p> Plugin Manager</p> <p>Central component for managing plugins</p> <p>Key Features: - Plugin loading and unloading - Plugin discovery and registration - Lifecycle management - Error handling and recovery</p> </li> <li> <p> Plugin Loader</p> <p>Handles dynamic loading of plugin libraries</p> <p>Key Features: - Cross-platform library loading - Symbol resolution - Dependency management - Error reporting</p> </li> <li> <p> Plugin Registry</p> <p>Maintains registry of available and loaded plugins</p> <p>Key Features: - Plugin metadata storage - Dependency tracking - Version management - Query interface</p> </li> </ul>"},{"location":"api/#communication-system","title":"Communication System","text":"<p>Inter-plugin communication and messaging:</p> <ul> <li> <p> Message Bus</p> <p>Central message routing and delivery system</p> <p>Key Features: - Type-safe messaging - Publish-subscribe pattern - Request-response communication - Event broadcasting</p> </li> <li> <p> Message Types</p> <p>Predefined message types and structures</p> <p>Key Features: - Standard message formats - Custom message support - Serialization helpers - Type validation</p> </li> </ul>"},{"location":"api/#security-system","title":"Security System","text":"<p>Plugin validation and security management:</p> <ul> <li> <p> Security Manager</p> <p>Comprehensive plugin security management</p> <p>Key Features: - Multi-layer validation - Trust management - Permission system - Security policies</p> </li> <li> <p> Plugin Validator</p> <p>Plugin validation and verification</p> <p>Key Features: - File integrity checking - Digital signature verification - Runtime validation - Security scanning</p> </li> </ul>"},{"location":"api/#utility-classes","title":"Utility Classes","text":"<p>Helper classes and common functionality:</p> <ul> <li> <p> Error Handling</p> <p>Modern error handling with <code>expected&lt;T, E&gt;</code></p> <p>Key Features: - Type-safe error handling - No exceptions - Composable error types - Rich error information</p> </li> <li> <p> Version</p> <p>Version information and comparison</p> <p>Key Features: - Semantic versioning - Version comparison - Compatibility checking - Version ranges</p> </li> <li> <p> Concepts</p> <p>C++20 concepts for type validation</p> <p>Key Features: - Compile-time validation - Plugin type concepts - Interface concepts - Constraint checking</p> </li> <li> <p> Helpers</p> <p>Utility functions and helpers</p> <p>Key Features: - Plugin creation helpers - CMake integration - Development utilities - Testing support</p> </li> </ul>"},{"location":"api/#optional-components","title":"Optional Components","text":"<p>Extended functionality for specific use cases:</p> <ul> <li> <p> Network</p> <p>Network-enabled plugin interfaces</p> <p>Requirements: Qt6::Network</p> <p>Key Features: - HTTP client/server plugins - WebSocket support - REST API integration - Network discovery</p> </li> <li> <p> UI</p> <p>User interface plugin support</p> <p>Requirements: Qt6::Widgets</p> <p>Key Features: - Widget-based plugins - Dialog integration - Custom UI components - Theme support</p> </li> </ul>"},{"location":"api/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/#basic-plugin-loading","title":"Basic Plugin Loading","text":"<pre><code>#include &lt;qtplugin/qtplugin.hpp&gt;\n\n// Initialize library\nqtplugin::LibraryInitializer init;\n\n// Create manager\nauto manager = qtplugin::PluginManager::create();\n\n// Load plugin\nauto result = manager-&gt;load_plugin(\"path/to/plugin.so\");\nif (result) {\n    auto plugin = manager-&gt;get_plugin(result.value());\n    auto init_result = plugin-&gt;initialize();\n    // Use plugin...\n}\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<pre><code>auto result = manager-&gt;load_plugin(\"plugin.so\");\nif (!result) {\n    std::cerr &lt;&lt; \"Failed to load plugin: \" \n              &lt;&lt; result.error().message &lt;&lt; std::endl;\n    return;\n}\n\n// Success path\nauto plugin_id = result.value();\n</code></pre>"},{"location":"api/#message-communication","title":"Message Communication","text":"<pre><code>// Get message bus\nauto&amp; bus = manager-&gt;message_bus();\n\n// Subscribe to messages\nbus.subscribe&lt;MyMessageType&gt;([](const MyMessageType&amp; msg) {\n    // Handle message\n});\n\n// Send message\nMyMessageType message{\"Hello, World!\"};\nbus.publish(message);\n</code></pre>"},{"location":"api/#api-conventions","title":"API Conventions","text":""},{"location":"api/#naming","title":"Naming","text":"<ul> <li>Classes: <code>PascalCase</code> (e.g., <code>PluginManager</code>)</li> <li>Functions: <code>snake_case</code> (e.g., <code>load_plugin</code>)</li> <li>Constants: <code>UPPER_SNAKE_CASE</code> (e.g., <code>MAX_PLUGINS</code>)</li> <li>Namespaces: <code>lowercase</code> (e.g., <code>qtplugin</code>)</li> </ul>"},{"location":"api/#error-handling_1","title":"Error Handling","text":"<p>QtPlugin uses the <code>expected&lt;T, E&gt;</code> pattern for error handling:</p> <pre><code>// Function that can fail\nqtplugin::expected&lt;std::string, qtplugin::PluginError&gt; \nload_plugin(const std::string&amp; path);\n\n// Usage\nauto result = load_plugin(\"plugin.so\");\nif (result) {\n    // Success - use result.value()\n} else {\n    // Error - use result.error()\n}\n</code></pre>"},{"location":"api/#memory-management","title":"Memory Management","text":"<ul> <li>RAII: All resources are automatically managed</li> <li>Smart Pointers: Use <code>std::shared_ptr</code> and <code>std::unique_ptr</code></li> <li>No Manual Memory Management: No need for <code>new</code>/<code>delete</code></li> </ul>"},{"location":"api/#thread-safety","title":"Thread Safety","text":"<ul> <li>Thread-Safe Classes: Marked in documentation</li> <li>Synchronization: Internal synchronization where needed</li> <li>Concurrent Access: Safe for multi-threaded applications</li> </ul>"},{"location":"api/#version-compatibility","title":"Version Compatibility","text":"QtPlugin Version Qt Version C++ Standard Status 3.0.x Qt 6.0+ C++20 Current 2.x.x Qt 5.15+ C++17 Legacy 1.x.x Qt 5.12+ C++14 Deprecated"},{"location":"api/#getting-started","title":"Getting Started","text":"<p>New to QtPlugin? Start with these guides:</p> <ol> <li>Getting Started - Overview and concepts</li> <li>Installation - Install QtPlugin</li> <li>Quick Start - First application</li> <li>First Plugin - Create a plugin</li> </ol>"},{"location":"api/#advanced-topics","title":"Advanced Topics","text":"<p>For advanced usage:</p> <ol> <li>Plugin Development - Comprehensive plugin guide</li> <li>Advanced Patterns - Advanced techniques</li> <li>Architecture - System design</li> <li>Best Practices - Production guidelines</li> </ol>"},{"location":"api/#support","title":"Support","text":"<ul> <li>Documentation: Browse this API reference</li> <li>Examples: Check examples</li> <li>Issues: Report on GitHub</li> <li>Discussions: Ask on GitHub Discussions</li> </ul>"},{"location":"api/core/plugin-interface/","title":"Plugin Interface","text":"<p>The <code>IPlugin</code> interface is the foundation of the QtPlugin system. All plugins must implement this interface to be compatible with the plugin manager.</p>"},{"location":"api/core/plugin-interface/#overview","title":"Overview","text":"<pre><code>#include &lt;qtplugin/core/plugin_interface.hpp&gt;\n\nclass IPlugin {\npublic:\n    virtual ~IPlugin() = default;\n\n    // Lifecycle management\n    virtual expected&lt;void, PluginError&gt; initialize() = 0;\n    virtual void shutdown() noexcept = 0;\n    virtual PluginState state() const noexcept = 0;\n    virtual bool is_initialized() const noexcept = 0;\n\n    // Metadata and identification\n    virtual PluginMetadata metadata() const = 0;\n    virtual std::string id() const noexcept = 0;\n    virtual std::string name() const noexcept = 0;\n    virtual std::string version() const noexcept = 0;\n    virtual std::string description() const noexcept = 0;\n    virtual std::string author() const noexcept = 0;\n\n    // Configuration management\n    virtual expected&lt;void, PluginError&gt; configure(const QJsonObject&amp; config) = 0;\n    virtual QJsonObject current_configuration() const = 0;\n\n    // Command execution\n    virtual expected&lt;QJsonObject, PluginError&gt; execute_command(\n        std::string_view command, \n        const QJsonObject&amp; params = {}\n    ) = 0;\n\n    // Capability queries\n    virtual std::vector&lt;std::string&gt; supported_commands() const = 0;\n    virtual bool supports_command(std::string_view command) const = 0;\n    virtual PluginCapabilities capabilities() const noexcept = 0;\n};\n</code></pre>"},{"location":"api/core/plugin-interface/#core-methods","title":"Core Methods","text":""},{"location":"api/core/plugin-interface/#lifecycle-management","title":"Lifecycle Management","text":""},{"location":"api/core/plugin-interface/#initialize","title":"<code>initialize()</code>","text":"<p>Initializes the plugin and prepares it for use.</p> <pre><code>virtual expected&lt;void, PluginError&gt; initialize() = 0;\n</code></pre> <p>Returns: - <code>expected&lt;void, PluginError&gt;</code>: Success or error information</p> <p>Example: <pre><code>expected&lt;void, PluginError&gt; MyPlugin::initialize() {\n    if (m_initialized) {\n        return make_unexpected(PluginError{\n            PluginErrorCode::AlreadyInitialized,\n            \"Plugin is already initialized\"\n        });\n    }\n\n    // Perform initialization\n    try {\n        setup_resources();\n        connect_signals();\n        m_initialized = true;\n        m_state = PluginState::Running;\n        return {};\n    } catch (const std::exception&amp; e) {\n        return make_unexpected(PluginError{\n            PluginErrorCode::InitializationFailed,\n            std::string(\"Initialization failed: \") + e.what()\n        });\n    }\n}\n</code></pre></p>"},{"location":"api/core/plugin-interface/#shutdown","title":"<code>shutdown()</code>","text":"<p>Cleanly shuts down the plugin and releases resources.</p> <pre><code>virtual void shutdown() noexcept = 0;\n</code></pre> <p>Notes: - Must be <code>noexcept</code> - cannot throw exceptions - Should handle cleanup gracefully even if initialization failed - Called automatically during plugin unloading</p> <p>Example: <pre><code>void MyPlugin::shutdown() noexcept {\n    try {\n        if (m_initialized) {\n            cleanup_resources();\n            disconnect_signals();\n            m_initialized = false;\n        }\n        m_state = PluginState::Unloaded;\n    } catch (...) {\n        // Log error but don't throw\n        qWarning() &lt;&lt; \"Error during plugin shutdown\";\n    }\n}\n</code></pre></p>"},{"location":"api/core/plugin-interface/#state","title":"<code>state()</code>","text":"<p>Returns the current state of the plugin.</p> <pre><code>virtual PluginState state() const noexcept = 0;\n</code></pre> <p>Returns: - <code>PluginState</code>: Current plugin state</p> <p>Plugin States: <pre><code>enum class PluginState {\n    Unloaded,    // Plugin not loaded or shut down\n    Loaded,      // Plugin loaded but not initialized\n    Running,     // Plugin initialized and running\n    Error        // Plugin in error state\n};\n</code></pre></p>"},{"location":"api/core/plugin-interface/#is_initialized","title":"<code>is_initialized()</code>","text":"<p>Quick check if the plugin is initialized and ready to use.</p> <pre><code>virtual bool is_initialized() const noexcept = 0;\n</code></pre> <p>Returns: - <code>bool</code>: <code>true</code> if plugin is initialized</p>"},{"location":"api/core/plugin-interface/#metadata-methods","title":"Metadata Methods","text":""},{"location":"api/core/plugin-interface/#metadata","title":"<code>metadata()</code>","text":"<p>Returns comprehensive plugin metadata.</p> <pre><code>virtual PluginMetadata metadata() const = 0;\n</code></pre> <p>Returns: - <code>PluginMetadata</code>: Complete plugin information</p> <p>PluginMetadata Structure: <pre><code>struct PluginMetadata {\n    std::string id;                          // Unique plugin identifier\n    std::string name;                        // Human-readable name\n    std::string version;                     // Version string\n    std::string description;                 // Plugin description\n    std::string author;                      // Author information\n    std::string license;                     // License information\n    std::vector&lt;std::string&gt; dependencies;   // Required dependencies\n    std::vector&lt;std::string&gt; tags;           // Classification tags\n    QJsonObject custom_data;                 // Custom metadata\n\n    // Version information\n    Version semantic_version;                // Parsed version\n    Version min_qtplugin_version;           // Minimum QtPlugin version\n    Version min_qt_version;                 // Minimum Qt version\n\n    // Capabilities\n    PluginCapabilities capabilities;         // Plugin capabilities\n    std::vector&lt;std::string&gt; interfaces;    // Implemented interfaces\n};\n</code></pre></p>"},{"location":"api/core/plugin-interface/#individual-metadata-methods","title":"Individual Metadata Methods","text":"<pre><code>virtual std::string id() const noexcept = 0;\nvirtual std::string name() const noexcept = 0;\nvirtual std::string version() const noexcept = 0;\nvirtual std::string description() const noexcept = 0;\nvirtual std::string author() const noexcept = 0;\n</code></pre> <p>These provide quick access to common metadata without creating the full structure.</p>"},{"location":"api/core/plugin-interface/#configuration-management","title":"Configuration Management","text":""},{"location":"api/core/plugin-interface/#configure","title":"<code>configure()</code>","text":"<p>Applies configuration to the plugin.</p> <pre><code>virtual expected&lt;void, PluginError&gt; configure(const QJsonObject&amp; config) = 0;\n</code></pre> <p>Parameters: - <code>config</code>: JSON configuration object</p> <p>Returns: - <code>expected&lt;void, PluginError&gt;</code>: Success or error information</p> <p>Example: <pre><code>expected&lt;void, PluginError&gt; MyPlugin::configure(const QJsonObject&amp; config) {\n    try {\n        // Validate configuration\n        if (!config.contains(\"required_setting\")) {\n            return make_unexpected(PluginError{\n                PluginErrorCode::InvalidConfiguration,\n                \"Missing required setting: required_setting\"\n            });\n        }\n\n        // Apply configuration\n        m_setting1 = config[\"setting1\"].toString();\n        m_setting2 = config[\"setting2\"].toInt();\n\n        // Store current configuration\n        m_current_config = config;\n\n        return {};\n    } catch (const std::exception&amp; e) {\n        return make_unexpected(PluginError{\n            PluginErrorCode::ConfigurationFailed,\n            std::string(\"Configuration failed: \") + e.what()\n        });\n    }\n}\n</code></pre></p>"},{"location":"api/core/plugin-interface/#current_configuration","title":"<code>current_configuration()</code>","text":"<p>Returns the current plugin configuration.</p> <pre><code>virtual QJsonObject current_configuration() const = 0;\n</code></pre> <p>Returns: - <code>QJsonObject</code>: Current configuration</p>"},{"location":"api/core/plugin-interface/#command-execution","title":"Command Execution","text":""},{"location":"api/core/plugin-interface/#execute_command","title":"<code>execute_command()</code>","text":"<p>Executes a plugin-specific command.</p> <pre><code>virtual expected&lt;QJsonObject, PluginError&gt; execute_command(\n    std::string_view command, \n    const QJsonObject&amp; params = {}\n) = 0;\n</code></pre> <p>Parameters: - <code>command</code>: Command name to execute - <code>params</code>: Command parameters (optional)</p> <p>Returns: - <code>expected&lt;QJsonObject, PluginError&gt;</code>: Command result or error</p> <p>Example: <pre><code>expected&lt;QJsonObject, PluginError&gt; MyPlugin::execute_command(\n    std::string_view command, \n    const QJsonObject&amp; params\n) {\n    if (command == \"hello\") {\n        QJsonObject result;\n        QString name = params.value(\"name\").toString(\"World\");\n        result[\"message\"] = QString(\"Hello, %1!\").arg(name);\n        result[\"timestamp\"] = QDateTime::currentDateTime().toString(Qt::ISODate);\n        return result;\n\n    } else if (command == \"status\") {\n        QJsonObject result;\n        result[\"state\"] = static_cast&lt;int&gt;(state());\n        result[\"initialized\"] = is_initialized();\n        result[\"uptime\"] = m_uptime_timer.elapsed();\n        return result;\n\n    } else {\n        return make_unexpected(PluginError{\n            PluginErrorCode::UnknownCommand,\n            std::string(\"Unknown command: \") + std::string(command)\n        });\n    }\n}\n</code></pre></p>"},{"location":"api/core/plugin-interface/#supported_commands","title":"<code>supported_commands()</code>","text":"<p>Returns list of supported commands.</p> <pre><code>virtual std::vector&lt;std::string&gt; supported_commands() const = 0;\n</code></pre> <p>Returns: - <code>std::vector&lt;std::string&gt;</code>: List of command names</p>"},{"location":"api/core/plugin-interface/#supports_command","title":"<code>supports_command()</code>","text":"<p>Checks if a specific command is supported.</p> <pre><code>virtual bool supports_command(std::string_view command) const = 0;\n</code></pre> <p>Parameters: - <code>command</code>: Command name to check</p> <p>Returns: - <code>bool</code>: <code>true</code> if command is supported</p>"},{"location":"api/core/plugin-interface/#capabilities","title":"Capabilities","text":""},{"location":"api/core/plugin-interface/#capabilities_1","title":"<code>capabilities()</code>","text":"<p>Returns the plugin's capabilities.</p> <pre><code>virtual PluginCapabilities capabilities() const noexcept = 0;\n</code></pre> <p>Returns: - <code>PluginCapabilities</code>: Plugin capability flags</p> <p>PluginCapabilities: <pre><code>enum class PluginCapability : uint32_t {\n    None = 0,\n    Service = 1 &lt;&lt; 0,        // Background service\n    UI = 1 &lt;&lt; 1,             // User interface\n    Network = 1 &lt;&lt; 2,        // Network operations\n    FileSystem = 1 &lt;&lt; 3,     // File system access\n    Database = 1 &lt;&lt; 4,       // Database operations\n    Scripting = 1 &lt;&lt; 5,      // Scripting support\n    HotReload = 1 &lt;&lt; 6,      // Hot reload support\n    MultiInstance = 1 &lt;&lt; 7,  // Multiple instances\n    ThreadSafe = 1 &lt;&lt; 8,     // Thread-safe operations\n\n    // Combinations\n    All = 0xFFFFFFFF\n};\n\nusing PluginCapabilities = QFlags&lt;PluginCapability&gt;;\n</code></pre></p>"},{"location":"api/core/plugin-interface/#implementation-example","title":"Implementation Example","text":"<p>Here's a complete example of implementing the <code>IPlugin</code> interface:</p> <pre><code>class MyExamplePlugin : public QObject, public qtplugin::IPlugin {\n    Q_OBJECT\n    Q_PLUGIN_METADATA(IID \"qtplugin.IPlugin/3.0\" FILE \"metadata.json\")\n    Q_INTERFACES(qtplugin::IPlugin)\n\npublic:\n    MyExamplePlugin(QObject* parent = nullptr);\n    ~MyExamplePlugin() override;\n\n    // Lifecycle\n    expected&lt;void, PluginError&gt; initialize() override;\n    void shutdown() noexcept override;\n    PluginState state() const noexcept override { return m_state; }\n    bool is_initialized() const noexcept override { return m_initialized; }\n\n    // Metadata\n    PluginMetadata metadata() const override;\n    std::string id() const noexcept override { return \"com.example.myplugin\"; }\n    std::string name() const noexcept override { return \"My Example Plugin\"; }\n    std::string version() const noexcept override { return \"1.0.0\"; }\n    std::string description() const noexcept override { return \"Example plugin\"; }\n    std::string author() const noexcept override { return \"Example Author\"; }\n\n    // Configuration\n    expected&lt;void, PluginError&gt; configure(const QJsonObject&amp; config) override;\n    QJsonObject current_configuration() const override;\n\n    // Commands\n    expected&lt;QJsonObject, PluginError&gt; execute_command(\n        std::string_view command, \n        const QJsonObject&amp; params = {}\n    ) override;\n\n    std::vector&lt;std::string&gt; supported_commands() const override;\n    bool supports_command(std::string_view command) const override;\n    PluginCapabilities capabilities() const noexcept override;\n\nprivate:\n    PluginState m_state = PluginState::Unloaded;\n    bool m_initialized = false;\n    QJsonObject m_config;\n    QElapsedTimer m_uptime_timer;\n};\n</code></pre>"},{"location":"api/core/plugin-interface/#best-practices","title":"Best Practices","text":""},{"location":"api/core/plugin-interface/#error-handling","title":"Error Handling","text":"<ul> <li>Always use <code>expected&lt;T, E&gt;</code> for operations that can fail</li> <li>Provide meaningful error messages</li> <li>Use appropriate error codes</li> <li>Handle exceptions and convert to errors</li> </ul>"},{"location":"api/core/plugin-interface/#resource-management","title":"Resource Management","text":"<ul> <li>Use RAII for resource management</li> <li>Clean up in <code>shutdown()</code> even if initialization failed</li> <li>Don't throw exceptions from <code>shutdown()</code></li> </ul>"},{"location":"api/core/plugin-interface/#thread-safety","title":"Thread Safety","text":"<ul> <li>Document thread safety guarantees</li> <li>Use appropriate synchronization</li> <li>Consider concurrent access patterns</li> </ul>"},{"location":"api/core/plugin-interface/#performance","title":"Performance","text":"<ul> <li>Keep metadata methods fast (they're called frequently)</li> <li>Cache expensive computations</li> <li>Use move semantics where appropriate</li> </ul>"},{"location":"api/core/plugin-interface/#see-also","title":"See Also","text":"<ul> <li>Plugin Manager - Managing plugins</li> <li>Plugin Loader - Loading plugins</li> <li>Error Handling - Error handling patterns</li> <li>Examples - Working examples</li> </ul>"},{"location":"appendix/faq/","title":"Frequently Asked Questions","text":"<p>This page answers common questions about QtPlugin. If you don't find your answer here, check the Troubleshooting Guide or ask on GitHub Discussions.</p>"},{"location":"appendix/faq/#general-questions","title":"General Questions","text":""},{"location":"appendix/faq/#what-is-qtplugin","title":"What is QtPlugin?","text":"<p>QtPlugin is a modern, enterprise-grade C++ plugin system built specifically for Qt applications. It provides a robust, type-safe, and performant way to add extensibility to your applications through dynamic plugin loading.</p> <p>Key Features: - Pure C++ implementation (no QML dependencies) - Modern C++20 features (concepts, coroutines, <code>std::expected</code>) - Type-safe plugin interfaces - Hot reloading support - Comprehensive security system - Cross-platform compatibility</p>"},{"location":"appendix/faq/#how-is-qtplugin-different-from-qts-built-in-plugin-system","title":"How is QtPlugin different from Qt's built-in plugin system?","text":"Feature QtPlugin Qt Built-in C++ Standard C++20 C++11/14 Error Handling <code>expected&lt;T,E&gt;</code> Exceptions/null pointers Type Safety Compile-time concepts Runtime checks Hot Reloading Built-in support Manual implementation Security Multi-layer validation Basic loading Communication Message bus system Manual implementation Dependencies Qt6::Core only Various Qt modules"},{"location":"appendix/faq/#is-qtplugin-production-ready","title":"Is QtPlugin production-ready?","text":"<p>Yes! QtPlugin v3.0.0 is production-ready with:</p> <ul> <li>\u2705 100% test coverage (181/181 tests passing)</li> <li>\u2705 Cross-platform support (Windows, Linux, macOS)</li> <li>\u2705 Comprehensive documentation</li> <li>\u2705 Active maintenance and support</li> <li>\u2705 Used in production by multiple organizations</li> </ul>"},{"location":"appendix/faq/#installation-and-setup","title":"Installation and Setup","text":""},{"location":"appendix/faq/#what-are-the-minimum-requirements","title":"What are the minimum requirements?","text":"<p>System Requirements: - Operating System: Windows 10+, Linux (Ubuntu 20.04+), macOS 10.15+ - Qt Version: Qt 6.0 or later (Qt 6.5+ recommended) - Compiler: C++20 compatible compiler   - GCC 10+ (Linux)   - Clang 12+ (macOS/Linux)   - MSVC 2019+ (Windows) - CMake: 3.21 or later</p> <p>Recommended Setup: - Qt 6.5+ for best compatibility - 4GB+ RAM for development - 2GB+ free storage for build artifacts</p>"},{"location":"appendix/faq/#can-i-use-qtplugin-with-qt-5","title":"Can I use QtPlugin with Qt 5?","text":"<p>No, QtPlugin requires Qt 6.0 or later. This is because:</p> <ul> <li>QtPlugin uses C++20 features not available in older Qt versions</li> <li>Qt 6 provides better CMake integration</li> <li>Modern Qt features are leveraged for performance and safety</li> </ul> <p>If you need Qt 5 support, consider: - Upgrading to Qt 6 (recommended) - Using QtPlugin v2.x (legacy, limited support) - Contributing Qt 5 backport patches</p>"},{"location":"appendix/faq/#how-do-i-install-qtplugin","title":"How do I install QtPlugin?","text":"<p>See the comprehensive Installation Guide for detailed instructions. Quick options:</p> CMake FetchContentvcpkgBuild from Source <pre><code>include(FetchContent)\nFetchContent_Declare(QtPlugin\n    GIT_REPOSITORY https://github.com/QtForge/QtPlugin.git\n    GIT_TAG v3.0.0\n)\nFetchContent_MakeAvailable(QtPlugin)\ntarget_link_libraries(your_app QtPlugin::Core)\n</code></pre> <pre><code>vcpkg install qtplugin\n</code></pre> <pre><code>git clone https://github.com/QtForge/QtPlugin.git\ncd QtPlugin &amp;&amp; mkdir build &amp;&amp; cd build\ncmake .. &amp;&amp; cmake --build . &amp;&amp; cmake --install .\n</code></pre>"},{"location":"appendix/faq/#development-questions","title":"Development Questions","text":""},{"location":"appendix/faq/#how-do-i-create-my-first-plugin","title":"How do I create my first plugin?","text":"<p>Follow the First Plugin Guide for a step-by-step tutorial. The basic steps are:</p> <ol> <li> <p>Implement the interface:    <pre><code>class MyPlugin : public QObject, public qtplugin::IPlugin {\n    Q_OBJECT\n    Q_PLUGIN_METADATA(IID \"qtplugin.IPlugin/3.0\" FILE \"metadata.json\")\n    Q_INTERFACES(qtplugin::IPlugin)\npublic:\n    // Implement IPlugin methods...\n};\n</code></pre></p> </li> <li> <p>Create metadata.json:    <pre><code>{\n    \"id\": \"com.example.myplugin\",\n    \"name\": \"My Plugin\",\n    \"version\": \"1.0.0\",\n    \"description\": \"My first plugin\"\n}\n</code></pre></p> </li> <li> <p>Build with CMake:    <pre><code>qtplugin_add_plugin(my_plugin\n    SOURCES my_plugin.cpp\n    METADATA metadata.json\n)\n</code></pre></p> </li> </ol>"},{"location":"appendix/faq/#whats-the-difference-between-static-and-dynamic-plugins","title":"What's the difference between static and dynamic plugins?","text":"Aspect Static Plugins Dynamic Plugins Loading Compile-time Runtime File Size Larger executable Smaller executable + plugin files Deployment Single file Multiple files Hot Reload Not supported Supported Performance Slightly faster Minimal overhead Use Case Fixed functionality Extensible applications <p>QtPlugin primarily supports dynamic plugins for maximum flexibility.</p>"},{"location":"appendix/faq/#how-do-i-handle-plugin-dependencies","title":"How do I handle plugin dependencies?","text":"<p>QtPlugin provides several mechanisms for dependency management:</p> <ol> <li> <p>Metadata Dependencies:    <pre><code>{\n    \"dependencies\": [\n        \"com.example.core-plugin@&gt;=1.0.0\",\n        \"com.example.utils@^2.1.0\"\n    ]\n}\n</code></pre></p> </li> <li> <p>Runtime Checks:    <pre><code>expected&lt;void, PluginError&gt; MyPlugin::initialize() {\n    auto core_plugin = manager-&gt;get_plugin(\"com.example.core-plugin\");\n    if (!core_plugin) {\n        return make_unexpected(PluginError{\n            PluginErrorCode::DependencyMissing,\n            \"Required core plugin not found\"\n        });\n    }\n    // Continue initialization...\n}\n</code></pre></p> </li> <li> <p>Automatic Resolution:    <pre><code>// Plugin manager automatically resolves dependencies\nauto result = manager-&gt;load_plugin_with_dependencies(\"my_plugin.so\");\n</code></pre></p> </li> </ol>"},{"location":"appendix/faq/#how-do-i-debug-plugin-loading-issues","title":"How do I debug plugin loading issues?","text":"<p>Enable detailed logging and use debugging techniques:</p> <ol> <li> <p>Enable Debug Logging:    <pre><code>// Set log level\nqtplugin::set_log_level(qtplugin::LogLevel::Debug);\n\n// Enable component logging\nqtplugin::enable_component_logging(true);\n</code></pre></p> </li> <li> <p>Check Error Details:    <pre><code>auto result = manager-&gt;load_plugin(\"plugin.so\");\nif (!result) {\n    auto error = result.error();\n    qDebug() &lt;&lt; \"Error code:\" &lt;&lt; static_cast&lt;int&gt;(error.code);\n    qDebug() &lt;&lt; \"Message:\" &lt;&lt; error.message.c_str();\n    qDebug() &lt;&lt; \"Details:\" &lt;&lt; error.details.c_str();\n}\n</code></pre></p> </li> <li> <p>Use Debug Builds:    <pre><code>cmake .. -DCMAKE_BUILD_TYPE=Debug -DQTPLUGIN_ENABLE_COMPONENT_LOGGING=ON\n</code></pre></p> </li> </ol>"},{"location":"appendix/faq/#architecture-questions","title":"Architecture Questions","text":""},{"location":"appendix/faq/#how-does-the-message-bus-work","title":"How does the message bus work?","text":"<p>The message bus provides type-safe inter-plugin communication:</p> <pre><code>// Subscribe to messages\nauto&amp; bus = manager-&gt;message_bus();\nbus.subscribe&lt;MyMessageType&gt;([](const MyMessageType&amp; msg) {\n    qDebug() &lt;&lt; \"Received message:\" &lt;&lt; msg.content;\n});\n\n// Publish messages\nMyMessageType message{\"Hello, World!\"};\nbus.publish(message);\n\n// Request-response pattern\nauto response = bus.request&lt;RequestType, ResponseType&gt;(request);\n</code></pre> <p>Key Features: - Type-safe messaging - Publish-subscribe pattern - Request-response communication - Asynchronous delivery - Thread-safe operations</p>"},{"location":"appendix/faq/#how-does-plugin-security-work","title":"How does plugin security work?","text":"<p>QtPlugin implements multi-layer security:</p> <ol> <li>File Validation:</li> <li>File integrity checks</li> <li>Digital signature verification</li> <li> <p>Malware scanning (optional)</p> </li> <li> <p>Runtime Validation:</p> </li> <li>Interface compliance</li> <li>Capability verification</li> <li> <p>Resource usage monitoring</p> </li> <li> <p>Trust Management:</p> </li> <li>Publisher trust levels</li> <li>Reputation system</li> <li> <p>Policy enforcement</p> </li> <li> <p>Sandboxing:</p> </li> <li>Resource limits</li> <li>Permission system</li> <li>Isolated execution</li> </ol> <p>Configure security levels: <pre><code>SecurityConfig config;\nconfig.validation_level = SecurityLevel::High;\nconfig.enable_sandboxing = true;\nconfig.max_memory_usage = 100 * 1024 * 1024; // 100MB\nmanager-&gt;configure_security(config);\n</code></pre></p>"},{"location":"appendix/faq/#can-plugins-communicate-with-each-other","title":"Can plugins communicate with each other?","text":"<p>Yes, through several mechanisms:</p> <ol> <li> <p>Message Bus (recommended):    <pre><code>// Plugin A publishes\nbus.publish(DataUpdateMessage{data});\n\n// Plugin B subscribes\nbus.subscribe&lt;DataUpdateMessage&gt;([this](const auto&amp; msg) {\n    handle_data_update(msg.data);\n});\n</code></pre></p> </li> <li> <p>Direct Interface Access:    <pre><code>// Get another plugin\nauto other_plugin = manager-&gt;get_plugin(\"other.plugin.id\");\nif (other_plugin) {\n    // Execute command\n    auto result = other_plugin-&gt;execute_command(\"get_data\");\n}\n</code></pre></p> </li> <li> <p>Shared Services:    <pre><code>// Register service\nmanager-&gt;register_service&lt;IDataService&gt;(std::make_shared&lt;DataService&gt;());\n\n// Use service from any plugin\nauto service = manager-&gt;get_service&lt;IDataService&gt;();\n</code></pre></p> </li> </ol>"},{"location":"appendix/faq/#performance-questions","title":"Performance Questions","text":""},{"location":"appendix/faq/#whats-the-performance-overhead-of-qtplugin","title":"What's the performance overhead of QtPlugin?","text":"<p>QtPlugin is designed for high performance:</p> <p>Benchmarks (typical values): - Plugin loading: 1.2ms average - Command execution: 0.05ms average - Memory usage: 2.1MB per plugin - Message passing: 0.01ms average - Concurrent operations: 1000+ ops/sec</p> <p>Optimization techniques: - Zero-cost abstractions where possible - Efficient memory management - Lazy loading of optional components - Optimized message routing</p>"},{"location":"appendix/faq/#how-many-plugins-can-i-load","title":"How many plugins can I load?","text":"<p>There's no hard limit, but practical considerations:</p> <p>Factors affecting plugin count: - Available memory - System resources - Plugin complexity - Inter-plugin dependencies</p> <p>Typical limits: - Desktop applications: 50-100 plugins - Server applications: 200+ plugins - Embedded systems: 10-20 plugins</p> <p>Optimization strategies: - Load plugins on-demand - Unload unused plugins - Use plugin pools - Implement lazy initialization</p>"},{"location":"appendix/faq/#how-do-i-optimize-plugin-loading-time","title":"How do I optimize plugin loading time?","text":"<p>Several strategies can improve loading performance:</p> <ol> <li> <p>Parallel Loading:    <pre><code>// Load multiple plugins concurrently\nstd::vector&lt;std::future&lt;expected&lt;std::string, PluginError&gt;&gt;&gt; futures;\nfor (const auto&amp; path : plugin_paths) {\n    futures.push_back(std::async(std::launch::async, [&amp;]() {\n        return manager-&gt;load_plugin(path);\n    }));\n}\n</code></pre></p> </li> <li> <p>Lazy Initialization:    <pre><code>// Load plugin but don't initialize immediately\nauto result = manager-&gt;load_plugin(path, LoadOptions{.initialize = false});\n\n// Initialize when needed\nauto plugin = manager-&gt;get_plugin(result.value());\nplugin-&gt;initialize();\n</code></pre></p> </li> <li> <p>Plugin Caching:    <pre><code>// Cache plugin metadata\nmanager-&gt;enable_metadata_cache(true);\n\n// Preload frequently used plugins\nmanager-&gt;preload_plugins({\"core.plugin\", \"ui.plugin\"});\n</code></pre></p> </li> </ol>"},{"location":"appendix/faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"appendix/faq/#plugin-fails-to-load-with-symbol-not-found","title":"Plugin fails to load with \"Symbol not found\"","text":"<p>This usually indicates ABI compatibility issues:</p> <p>Solutions: 1. Check compiler compatibility:    - Ensure plugin and application use same compiler    - Verify C++ standard library compatibility</p> <ol> <li>Verify Qt versions:</li> <li>Plugin and application must use same Qt version</li> <li> <p>Check Qt module dependencies</p> </li> <li> <p>Debug symbols:    <pre><code># Check exported symbols (Linux)\nnm -D plugin.so | grep qtplugin\n\n# Check dependencies\nldd plugin.so  # Linux\notool -L plugin.so  # macOS\n</code></pre></p> </li> </ol>"},{"location":"appendix/faq/#plugin-loads-but-initialization-fails","title":"Plugin loads but initialization fails","text":"<p>Common causes and solutions:</p> <ol> <li> <p>Missing dependencies:    <pre><code>// Check error details\nauto result = plugin-&gt;initialize();\nif (!result) {\n    qDebug() &lt;&lt; \"Init failed:\" &lt;&lt; result.error().message.c_str();\n}\n</code></pre></p> </li> <li> <p>Resource issues:</p> </li> <li>Check file permissions</li> <li>Verify required files exist</li> <li> <p>Ensure sufficient memory</p> </li> <li> <p>Configuration problems:</p> </li> <li>Validate configuration format</li> <li>Check required settings</li> <li>Verify data types</li> </ol>"},{"location":"appendix/faq/#application-crashes-when-loading-plugins","title":"Application crashes when loading plugins","text":"<p>Safety measures and debugging:</p> <ol> <li> <p>Use safe loading:    <pre><code>try {\n    auto result = manager-&gt;load_plugin_safe(path);\n} catch (const std::exception&amp; e) {\n    qDebug() &lt;&lt; \"Safe loading caught exception:\" &lt;&lt; e.what();\n}\n</code></pre></p> </li> <li> <p>Enable crash reporting:    <pre><code>manager-&gt;enable_crash_reporting(true);\nmanager-&gt;set_crash_handler([](const CrashInfo&amp; info) {\n    qDebug() &lt;&lt; \"Plugin crash:\" &lt;&lt; info.plugin_id &lt;&lt; info.reason;\n});\n</code></pre></p> </li> <li> <p>Use debug builds:</p> </li> <li>Build with debug symbols</li> <li>Enable address sanitizer</li> <li>Use memory debugging tools</li> </ol>"},{"location":"appendix/faq/#getting-help","title":"Getting Help","text":""},{"location":"appendix/faq/#where-can-i-get-support","title":"Where can I get support?","text":"<ul> <li>\ud83d\udcd6 Documentation: Browse this comprehensive documentation</li> <li>\ud83d\udca1 Examples: Check the examples directory</li> <li>\ud83d\udc1b Bug Reports: GitHub Issues</li> <li>\ud83d\udcac Questions: GitHub Discussions</li> <li>\ud83d\udce7 Enterprise Support: Contact maintainers for commercial support</li> </ul>"},{"location":"appendix/faq/#how-do-i-report-a-bug","title":"How do I report a bug?","text":"<p>When reporting bugs, please include:</p> <ol> <li>System Information:</li> <li>Operating system and version</li> <li>Qt version</li> <li>Compiler version</li> <li> <p>QtPlugin version</p> </li> <li> <p>Reproduction Steps:</p> </li> <li>Minimal code example</li> <li>Steps to reproduce</li> <li> <p>Expected vs actual behavior</p> </li> <li> <p>Error Information:</p> </li> <li>Complete error messages</li> <li>Stack traces (if available)</li> <li> <p>Log output with debug enabled</p> </li> <li> <p>Additional Context:</p> </li> <li>Plugin metadata</li> <li>Configuration files</li> <li>Build configuration</li> </ol>"},{"location":"appendix/faq/#how-do-i-contribute","title":"How do I contribute?","text":"<p>We welcome contributions! See the Contributing Guide for details:</p> <ol> <li>Code Contributions: Bug fixes, features, improvements</li> <li>Documentation: Guides, examples, API docs</li> <li>Testing: Test cases, bug reports, validation</li> <li>Community: Help others, answer questions</li> </ol> <p>Getting Started: 1. Fork the repository 2. Create a feature branch 3. Make your changes 4. Add tests 5. Submit a pull request</p> <p>Still have questions? Ask on GitHub Discussions!</p>"},{"location":"contributing/","title":"Contributing to QtPlugin","text":"<p>Thank you for your interest in contributing to QtPlugin! This guide provides everything you need to know to contribute effectively to the project.</p>"},{"location":"contributing/#ways-to-contribute","title":"\ud83c\udfaf Ways to Contribute","text":"<p>We welcome several types of contributions:</p> <ul> <li> <p> Bug Reports</p> <p>Help us identify and fix issues</p> <ul> <li>Report bugs and unexpected behavior</li> <li>Provide detailed reproduction steps</li> <li>Include system information and logs</li> </ul> <p> Report a Bug</p> </li> <li> <p> Feature Requests</p> <p>Suggest new features and improvements</p> <ul> <li>Propose new functionality</li> <li>Discuss API enhancements</li> <li>Share use case requirements</li> </ul> <p> Request Feature</p> </li> <li> <p> Code Contributions</p> <p>Implement features and fix bugs</p> <ul> <li>Fix reported issues</li> <li>Implement new features</li> <li>Improve performance</li> <li>Add platform support</li> </ul> <p> Development Setup</p> </li> <li> <p> Documentation</p> <p>Improve documentation and examples</p> <ul> <li>Fix documentation errors</li> <li>Add missing documentation</li> <li>Create tutorials and guides</li> <li>Improve API documentation</li> </ul> <p> Documentation Guide</p> </li> <li> <p> Testing</p> <p>Improve test coverage and quality</p> <ul> <li>Write unit tests</li> <li>Add integration tests</li> <li>Test on different platforms</li> <li>Performance testing</li> </ul> <p> Testing Guidelines</p> </li> <li> <p> Examples</p> <p>Create examples and tutorials</p> <ul> <li>Build example plugins</li> <li>Write tutorials</li> <li>Create demo applications</li> <li>Share best practices</li> </ul> <p> Example Guidelines</p> </li> </ul>"},{"location":"contributing/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"contributing/#quick-start-for-contributors","title":"Quick Start for Contributors","text":"<ol> <li> <p>Fork the Repository <pre><code># Fork on GitHub, then clone your fork\ngit clone https://github.com/YOUR_USERNAME/QtPlugin.git\ncd QtPlugin\n</code></pre></p> </li> <li> <p>Set Up Development Environment <pre><code># Install dependencies (see Development Setup guide)\n# Configure your IDE\n# Set up pre-commit hooks\n</code></pre></p> </li> <li> <p>Create a Branch <pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b bugfix/issue-number\n</code></pre></p> </li> <li> <p>Make Changes</p> </li> <li>Follow our Coding Standards</li> <li>Write tests for your changes</li> <li> <p>Update documentation as needed</p> </li> <li> <p>Submit Pull Request</p> </li> <li>Push your branch to your fork</li> <li>Create a pull request on GitHub</li> <li>Follow our PR template</li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<pre><code>graph LR\n    A[Fork Repository] --&gt; B[Clone Fork]\n    B --&gt; C[Create Branch]\n    C --&gt; D[Make Changes]\n    D --&gt; E[Write Tests]\n    E --&gt; F[Update Docs]\n    F --&gt; G[Commit Changes]\n    G --&gt; H[Push Branch]\n    H --&gt; I[Create PR]\n    I --&gt; J[Code Review]\n    J --&gt; K[Merge]</code></pre>"},{"location":"contributing/#contribution-guidelines","title":"\ud83d\udccb Contribution Guidelines","text":""},{"location":"contributing/#code-quality-standards","title":"Code Quality Standards","text":"<ul> <li>Modern C++20: Use latest C++ features appropriately</li> <li>Type Safety: Prefer compile-time checks over runtime</li> <li>Error Handling: Use <code>expected&lt;T,E&gt;</code> pattern consistently</li> <li>Memory Safety: Follow RAII principles</li> <li>Thread Safety: Document and ensure thread safety</li> <li>Performance: Consider performance implications</li> </ul>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We follow a consistent code style enforced by automated tools:</p> <pre><code>// Class names: PascalCase\nclass PluginManager {\npublic:\n    // Method names: snake_case\n    expected&lt;std::string, PluginError&gt; load_plugin(const std::string&amp; path);\n\n    // Member variables: m_ prefix, snake_case\nprivate:\n    std::unique_ptr&lt;PluginLoader&gt; m_loader;\n    mutable std::shared_mutex m_plugins_mutex;\n};\n\n// Constants: UPPER_SNAKE_CASE\nconstexpr int MAX_PLUGINS = 1000;\n\n// Namespaces: lowercase\nnamespace qtplugin {\n    // ...\n}\n</code></pre>"},{"location":"contributing/#commit-message-format","title":"Commit Message Format","text":"<p>Use conventional commit format:</p> <pre><code>type(scope): brief description\n\nDetailed explanation of the change, including:\n- What was changed and why\n- Any breaking changes\n- References to issues\n\nFixes #123\n</code></pre> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation changes - <code>style</code>: Code style changes - <code>refactor</code>: Code refactoring - <code>test</code>: Test additions/changes - <code>chore</code>: Build/tooling changes</p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Before Submitting:</li> <li>Ensure all tests pass</li> <li>Run code formatting tools</li> <li>Update documentation</li> <li> <p>Add changelog entry</p> </li> <li> <p>PR Description:</p> </li> <li>Clear title and description</li> <li>Link to related issues</li> <li>List breaking changes</li> <li> <p>Include testing instructions</p> </li> <li> <p>Review Process:</p> </li> <li>Address reviewer feedback</li> <li>Keep PR focused and small</li> <li>Maintain clean commit history</li> </ol>"},{"location":"contributing/#development-areas","title":"\ud83c\udfd7\ufe0f Development Areas","text":""},{"location":"contributing/#core-library","title":"Core Library","text":"<p>The heart of QtPlugin with essential functionality:</p> <p>Areas for contribution: - Plugin loading and management - Error handling improvements - Performance optimizations - Memory management - Cross-platform compatibility</p> <p>Skills needed: - Advanced C++20 knowledge - Qt framework experience - System programming - Performance optimization</p>"},{"location":"contributing/#security-system","title":"Security System","text":"<p>Plugin validation and trust management:</p> <p>Areas for contribution: - Signature verification - Sandboxing improvements - Trust management - Security policies - Vulnerability scanning</p> <p>Skills needed: - Security expertise - Cryptography knowledge - System security - Risk assessment</p>"},{"location":"contributing/#communication-system","title":"Communication System","text":"<p>Inter-plugin messaging and events:</p> <p>Areas for contribution: - Message routing optimization - New message types - Serialization improvements - Network communication - Event system enhancements</p> <p>Skills needed: - Distributed systems - Network programming - Serialization formats - Event-driven architecture</p>"},{"location":"contributing/#platform-support","title":"Platform Support","text":"<p>Cross-platform compatibility and optimization:</p> <p>Areas for contribution: - Windows platform improvements - macOS optimizations - Linux distribution support - Mobile platform support - Embedded systems</p> <p>Skills needed: - Platform-specific knowledge - Build system expertise - Package management - Cross-compilation</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Comprehensive documentation and examples:</p> <p>Areas for contribution: - API documentation - Tutorial creation - Example development - Translation - Video tutorials</p> <p>Skills needed: - Technical writing - Documentation tools - Example development - Teaching ability</p>"},{"location":"contributing/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"contributing/#test-categories","title":"Test Categories","text":"<ol> <li>Unit Tests: Test individual components</li> <li>Integration Tests: Test component interactions</li> <li>System Tests: Test complete workflows</li> <li>Performance Tests: Measure and validate performance</li> <li>Platform Tests: Ensure cross-platform compatibility</li> </ol>"},{"location":"contributing/#testing-tools","title":"Testing Tools","text":"<ul> <li>Qt Test Framework: Primary testing framework</li> <li>Google Test: Alternative for non-Qt components</li> <li>Benchmark: Performance testing</li> <li>Valgrind: Memory testing (Linux)</li> <li>AddressSanitizer: Memory error detection</li> </ul>"},{"location":"contributing/#test-requirements","title":"Test Requirements","text":"<ul> <li>All new features must include tests</li> <li>Bug fixes must include regression tests</li> <li>Tests must be deterministic and fast</li> <li>Platform-specific tests for platform features</li> </ul>"},{"location":"contributing/#learning-resources","title":"\ud83d\udcda Learning Resources","text":""},{"location":"contributing/#getting-familiar-with-qtplugin","title":"Getting Familiar with QtPlugin","text":"<ol> <li>Getting Started: Understand the basics</li> <li>API Reference: Learn the API</li> <li>Architecture: Understand the design</li> <li>Examples: Study working code</li> </ol>"},{"location":"contributing/#c20-and-qt-resources","title":"C++20 and Qt Resources","text":"<ul> <li>C++20 Features: cppreference.com</li> <li>Qt Documentation: doc.qt.io</li> <li>Modern C++ Guidelines: isocpp.github.io</li> </ul>"},{"location":"contributing/#development-tools","title":"Development Tools","text":"<ul> <li>IDEs: Qt Creator, Visual Studio, CLion</li> <li>Build Tools: CMake, Ninja</li> <li>Version Control: Git, GitHub</li> <li>Debugging: GDB, LLDB, Visual Studio Debugger</li> </ul>"},{"location":"contributing/#community","title":"\ud83e\udd1d Community","text":""},{"location":"contributing/#communication-channels","title":"Communication Channels","text":"<ul> <li>GitHub Discussions: General discussions</li> <li>GitHub Issues: Bug reports and feature requests</li> <li>Discord Server: Real-time chat</li> <li>Mailing List: Development discussions</li> </ul>"},{"location":"contributing/#community-guidelines","title":"Community Guidelines","text":"<ul> <li>Be Respectful: Treat everyone with respect and kindness</li> <li>Be Constructive: Provide helpful feedback and suggestions</li> <li>Be Patient: Remember that everyone is learning</li> <li>Be Inclusive: Welcome contributors from all backgrounds</li> </ul>"},{"location":"contributing/#mentorship","title":"Mentorship","text":"<p>New contributors can get help from experienced maintainers:</p> <ul> <li>Good First Issues: Issues labeled for newcomers</li> <li>Mentorship Program: Pairing with experienced contributors</li> <li>Code Review: Learning through the review process</li> <li>Office Hours: Regular Q&amp;A sessions</li> </ul>"},{"location":"contributing/#recognition","title":"\ud83c\udfc6 Recognition","text":"<p>We value all contributions and recognize contributors:</p>"},{"location":"contributing/#contributor-recognition","title":"Contributor Recognition","text":"<ul> <li>Contributors File: Listed in CONTRIBUTORS.md</li> <li>Release Notes: Mentioned in release announcements</li> <li>GitHub Profile: Contributions visible on GitHub</li> <li>Special Thanks: Recognition for significant contributions</li> </ul>"},{"location":"contributing/#maintainer-path","title":"Maintainer Path","text":"<p>Active contributors may be invited to become maintainers:</p> <ol> <li>Regular Contributions: Consistent, quality contributions</li> <li>Community Involvement: Helping other contributors</li> <li>Technical Expertise: Deep understanding of the codebase</li> <li>Leadership: Taking initiative on improvements</li> </ol>"},{"location":"contributing/#getting-help","title":"\ud83d\udcde Getting Help","text":""},{"location":"contributing/#for-contributors","title":"For Contributors","text":"<ul> <li>Development Setup: Environment setup</li> <li>Coding Standards: Code style guide</li> <li>Testing Guidelines: Testing best practices</li> <li>GitHub Discussions: Ask questions</li> </ul>"},{"location":"contributing/#for-maintainers","title":"For Maintainers","text":"<ul> <li>Maintainer Guide: Internal documentation</li> <li>Release Process: How to create releases</li> <li>Security Policy: Handling security issues</li> <li>Governance: Project governance model</li> </ul>"},{"location":"contributing/#thank-you","title":"\ud83c\udf89 Thank You!","text":"<p>Every contribution, no matter how small, helps make QtPlugin better. Whether you're fixing a typo, reporting a bug, or implementing a major feature, your efforts are appreciated by the entire community.</p> <p>Ready to contribute? Start with our Development Setup guide!</p>"},{"location":"examples/","title":"Examples","text":"<p>This section provides comprehensive examples demonstrating QtPlugin's capabilities. Each example includes complete source code, detailed explanations, and practical use cases.</p>"},{"location":"examples/#example-categories","title":"\ud83d\udcda Example Categories","text":""},{"location":"examples/#getting-started-examples","title":"\ud83c\udfaf Getting Started Examples","text":"<p>Perfect for beginners learning QtPlugin fundamentals:</p> <ul> <li> <p> Basic Plugin</p> <p>Simple \"Hello World\" plugin demonstrating core concepts</p> <p>Features: - Plugin interface implementation - Command execution - Configuration management - Lifecycle handling</p> <p>Difficulty: Beginner</p> </li> <li> <p> Service Plugin</p> <p>Background service with timer-based processing</p> <p>Features: - Background processing - Timer management - State persistence - Resource monitoring</p> <p>Difficulty: Intermediate</p> </li> </ul>"},{"location":"examples/#advanced-examples","title":"\ud83c\udf10 Advanced Examples","text":"<p>For developers building production applications:</p> <ul> <li> <p> Network Plugin</p> <p>HTTP client/server plugin with REST API</p> <p>Features: - HTTP requests/responses - REST API integration - Async networking - Error handling</p> <p>Difficulty: Advanced</p> </li> <li> <p> UI Plugin</p> <p>Plugin with custom user interface</p> <p>Features: - Qt Widgets integration - Custom dialogs - Event handling - Theme support</p> <p>Difficulty: Advanced</p> </li> </ul>"},{"location":"examples/#architecture-examples","title":"\ud83c\udfd7\ufe0f Architecture Examples","text":"<p>Demonstrating advanced architectural patterns:</p> <ul> <li> <p> Plugin Composition</p> <p>Multiple plugins working together</p> <p>Features: - Inter-plugin communication - Dependency management - Service registration - Event coordination</p> </li> <li> <p> Message Bus Usage</p> <p>Advanced messaging patterns</p> <p>Features: - Publish-subscribe - Request-response - Event broadcasting - Type-safe messaging</p> </li> </ul>"},{"location":"examples/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>All examples are included in the QtPlugin repository:</p> <pre><code># Clone repository\ngit clone https://github.com/QtForge/QtPlugin.git\ncd QtPlugin\n\n# Build with examples\nmkdir build &amp;&amp; cd build\ncmake .. -DQTPLUGIN_BUILD_EXAMPLES=ON\ncmake --build .\n\n# Run examples\ncd examples\n./basic_plugin_demo\n./service_plugin_demo\n./network_plugin_demo\n</code></pre>"},{"location":"examples/#example-structure","title":"Example Structure","text":"<p>Each example follows this structure:</p> <pre><code>example_name/\n\u251c\u2500\u2500 CMakeLists.txt          # Build configuration\n\u251c\u2500\u2500 README.md               # Example-specific documentation\n\u251c\u2500\u2500 plugin/                 # Plugin source code\n\u2502   \u251c\u2500\u2500 plugin.hpp\n\u2502   \u251c\u2500\u2500 plugin.cpp\n\u2502   \u2514\u2500\u2500 metadata.json\n\u251c\u2500\u2500 app/                    # Test application\n\u2502   \u2514\u2500\u2500 main.cpp\n\u2514\u2500\u2500 tests/                  # Unit tests\n    \u2514\u2500\u2500 test_plugin.cpp\n</code></pre>"},{"location":"examples/#learning-path","title":"\ud83d\udcd6 Learning Path","text":""},{"location":"examples/#beginner-path","title":"\ud83c\udfaf Beginner Path","text":"<ol> <li>Basic Plugin - Start here to understand fundamentals</li> <li>Service Plugin - Learn background processing</li> <li>Configuration Examples - Master plugin configuration</li> </ol>"},{"location":"examples/#intermediate-path","title":"\ud83d\ude80 Intermediate Path","text":"<ol> <li>Network Plugin - Add network capabilities</li> <li>UI Plugin - Create user interfaces</li> <li>Message Bus Examples - Inter-plugin communication</li> </ol>"},{"location":"examples/#advanced-path","title":"\ud83c\udfc6 Advanced Path","text":"<ol> <li>Plugin Composition - Complex architectures</li> <li>Security Examples - Plugin validation and trust</li> <li>Performance Optimization - High-performance plugins</li> </ol>"},{"location":"examples/#development-tools","title":"\ud83d\udd27 Development Tools","text":""},{"location":"examples/#cmake-helpers","title":"CMake Helpers","text":"<p>QtPlugin provides CMake functions to simplify plugin development:</p> <pre><code># Create a plugin\nqtplugin_add_plugin(my_plugin\n    TYPE service\n    SOURCES src/plugin.cpp\n    HEADERS include/plugin.hpp\n    METADATA metadata.json\n    DEPENDENCIES Qt6::Network\n)\n\n# Create plugin test\nqtplugin_add_plugin_test(my_plugin_test\n    PLUGIN my_plugin\n    SOURCES tests/test_plugin.cpp\n)\n\n# Find plugins in directory\nqtplugin_find_plugins(PLUGIN_FILES \"${CMAKE_CURRENT_SOURCE_DIR}/plugins\")\n</code></pre>"},{"location":"examples/#testing-framework","title":"Testing Framework","text":"<p>Use QtPlugin's testing framework for plugin tests:</p> <pre><code>#include &lt;qtplugin/testing/plugin_test_framework.hpp&gt;\n\nclass PluginTest : public QObject {\n    Q_OBJECT\n\nprivate slots:\n    void testPluginLoading();\n    void testPluginCommands();\n};\n\nvoid PluginTest::testPluginLoading() {\n    qtplugin::testing::PluginTestFramework framework;\n\n    auto result = framework.load_test_plugin(\"my_plugin.so\");\n    QVERIFY(result.has_value());\n\n    auto plugin = framework.get_plugin(result.value());\n    QVERIFY(plugin != nullptr);\n    QVERIFY(plugin-&gt;is_initialized());\n}\n</code></pre>"},{"location":"examples/#debug-tools","title":"Debug Tools","text":"<p>Enable debugging for plugin development:</p> <pre><code>// Enable debug logging\nqtplugin::set_log_level(qtplugin::LogLevel::Debug);\nqtplugin::enable_component_logging(true);\n\n// Enable plugin profiling\nmanager-&gt;enable_profiling(true);\n\n// Get performance metrics\nauto metrics = manager-&gt;performance_metrics();\nqDebug() &lt;&lt; \"Plugin loading time:\" &lt;&lt; metrics.average_load_time;\n</code></pre>"},{"location":"examples/#example-comparison","title":"\ud83d\udcca Example Comparison","text":"Example Complexity Features Use Cases Basic Plugin \u2b50 Commands, Config Learning, Simple tools Service Plugin \u2b50\u2b50 Background tasks Monitoring, Processing Network Plugin \u2b50\u2b50\u2b50 HTTP, REST API Web services, APIs UI Plugin \u2b50\u2b50\u2b50 Widgets, Dialogs Desktop apps, Tools Advanced \u2b50\u2b50\u2b50\u2b50 Multi-plugin Enterprise apps"},{"location":"examples/#use-case-examples","title":"\ud83c\udfaf Use Case Examples","text":""},{"location":"examples/#desktop-applications","title":"Desktop Applications","text":"<ul> <li>Text Editor Plugins: Syntax highlighting, code completion</li> <li>Media Player Plugins: Codecs, visualizations, effects</li> <li>IDE Extensions: Language support, debugging tools</li> </ul>"},{"location":"examples/#server-applications","title":"Server Applications","text":"<ul> <li>Web Server Modules: Authentication, logging, caching</li> <li>Database Plugins: Drivers, connection pooling, migrations</li> <li>Monitoring Plugins: Metrics collection, alerting</li> </ul>"},{"location":"examples/#embedded-systems","title":"Embedded Systems","text":"<ul> <li>Device Drivers: Hardware abstraction, communication</li> <li>Protocol Handlers: Network protocols, data formats</li> <li>Control Systems: Sensors, actuators, automation</li> </ul>"},{"location":"examples/#code-patterns","title":"\ud83d\udd0d Code Patterns","text":""},{"location":"examples/#common-plugin-patterns","title":"Common Plugin Patterns","text":"<ol> <li> <p>Command Pattern:    <pre><code>auto result = plugin-&gt;execute_command(\"process_data\", params);\n</code></pre></p> </li> <li> <p>Observer Pattern:    <pre><code>bus.subscribe&lt;DataUpdateEvent&gt;([](const auto&amp; event) {\n    // Handle data update\n});\n</code></pre></p> </li> <li> <p>Factory Pattern:    <pre><code>auto processor = plugin-&gt;create_processor(ProcessorType::Advanced);\n</code></pre></p> </li> <li> <p>Strategy Pattern:    <pre><code>plugin-&gt;set_algorithm(std::make_unique&lt;FastAlgorithm&gt;());\n</code></pre></p> </li> </ol>"},{"location":"examples/#error-handling-patterns","title":"Error Handling Patterns","text":"<pre><code>// Check and handle errors\nauto result = plugin-&gt;execute_command(\"risky_operation\");\nif (!result) {\n    switch (result.error().code) {\n        case PluginErrorCode::NotInitialized:\n            // Handle not initialized\n            break;\n        case PluginErrorCode::InvalidParameters:\n            // Handle invalid parameters\n            break;\n        default:\n            // Handle other errors\n            break;\n    }\n}\n</code></pre>"},{"location":"examples/#testing-examples","title":"\ud83e\uddea Testing Examples","text":""},{"location":"examples/#unit-testing","title":"Unit Testing","text":"<pre><code>void TestMyPlugin::testCommandExecution() {\n    // Setup\n    MyPlugin plugin;\n    QVERIFY(plugin.initialize().has_value());\n\n    // Test\n    QJsonObject params{{\"input\", \"test_data\"}};\n    auto result = plugin.execute_command(\"process\", params);\n\n    // Verify\n    QVERIFY(result.has_value());\n    QCOMPARE(result.value()[\"status\"].toString(), \"success\");\n}\n</code></pre>"},{"location":"examples/#integration-testing","title":"Integration Testing","text":"<pre><code>void TestPluginIntegration::testPluginCommunication() {\n    // Load multiple plugins\n    auto manager = qtplugin::PluginManager::create();\n    auto producer_id = manager-&gt;load_plugin(\"producer_plugin.so\");\n    auto consumer_id = manager-&gt;load_plugin(\"consumer_plugin.so\");\n\n    // Test communication\n    auto&amp; bus = manager-&gt;message_bus();\n    bool message_received = false;\n\n    bus.subscribe&lt;TestMessage&gt;([&amp;](const TestMessage&amp; msg) {\n        message_received = true;\n    });\n\n    bus.publish(TestMessage{\"test\"});\n\n    // Wait and verify\n    QTest::qWait(100);\n    QVERIFY(message_received);\n}\n</code></pre>"},{"location":"examples/#additional-resources","title":"\ud83d\udcda Additional Resources","text":""},{"location":"examples/#documentation","title":"Documentation","text":"<ul> <li>API Reference: Complete API documentation</li> <li>Developer Guide: Advanced development</li> <li>Best Practices: Production guidelines</li> </ul>"},{"location":"examples/#community-examples","title":"Community Examples","text":"<ul> <li>GitHub Repository: Official examples</li> <li>Community Plugins: Community contributions</li> <li>Plugin Registry: Discover existing plugins</li> </ul>"},{"location":"examples/#getting-help","title":"Getting Help","text":"<ul> <li>FAQ: Common questions and answers</li> <li>Troubleshooting: Problem solving guide</li> <li>GitHub Discussions: Community support</li> </ul> <p>Ready to start? Begin with the Basic Plugin example!</p>"},{"location":"getting-started/first-plugin/","title":"Your First Plugin","text":"<p>This guide walks you through creating your first QtPlugin plugin from scratch. By the end, you'll have a working plugin that demonstrates the core concepts and can be loaded by any QtPlugin application.</p>"},{"location":"getting-started/first-plugin/#what-well-build","title":"What We'll Build","text":"<p>We'll create a simple \"Hello World\" plugin that:</p> <ul> <li>\u2705 Implements the <code>IPlugin</code> interface</li> <li>\u2705 Provides metadata and identification</li> <li>\u2705 Supports basic commands</li> <li>\u2705 Handles configuration</li> <li>\u2705 Demonstrates proper lifecycle management</li> </ul>"},{"location":"getting-started/first-plugin/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>\u2705 QtPlugin installed (see Installation Guide)</li> <li>\u2705 Basic understanding of C++ and Qt</li> <li>\u2705 CMake 3.21+ and a C++20 compiler</li> <li>\u2705 A working QtPlugin application (from Quick Start)</li> </ul>"},{"location":"getting-started/first-plugin/#step-1-project-setup","title":"Step 1: Project Setup","text":""},{"location":"getting-started/first-plugin/#create-project-structure","title":"Create Project Structure","text":"<pre><code>mkdir my_first_plugin\ncd my_first_plugin\n\n# Create directory structure\nmkdir -p src include\ntouch CMakeLists.txt\ntouch src/hello_plugin.cpp\ntouch include/hello_plugin.hpp\ntouch metadata.json\n</code></pre> <p>Your project structure should look like:</p> <pre><code>my_first_plugin/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 metadata.json\n\u251c\u2500\u2500 include/\n\u2502   \u2514\u2500\u2500 hello_plugin.hpp\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 hello_plugin.cpp\n</code></pre>"},{"location":"getting-started/first-plugin/#cmakeliststxt","title":"CMakeLists.txt","text":"<pre><code>cmake_minimum_required(VERSION 3.21)\nproject(HelloPlugin VERSION 1.0.0 LANGUAGES CXX)\n\n# Set C++20 standard\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# Find required packages\nfind_package(Qt6 REQUIRED COMPONENTS Core)\nfind_package(QtPlugin REQUIRED COMPONENTS Core)\n\n# Create the plugin\nqtplugin_add_plugin(hello_plugin\n    TYPE service\n    SOURCES \n        src/hello_plugin.cpp\n    HEADERS \n        include/hello_plugin.hpp\n    METADATA \n        metadata.json\n    INCLUDE_DIRECTORIES\n        include\n    DEPENDENCIES\n        Qt6::Core\n        QtPlugin::Core\n)\n\n# Set output directory\nset_target_properties(hello_plugin PROPERTIES\n    LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/plugins\n)\n</code></pre>"},{"location":"getting-started/first-plugin/#step-2-plugin-metadata","title":"Step 2: Plugin Metadata","text":""},{"location":"getting-started/first-plugin/#metadatajson","title":"metadata.json","text":"<pre><code>{\n    \"id\": \"com.example.hello-plugin\",\n    \"name\": \"Hello World Plugin\",\n    \"version\": \"1.0.0\",\n    \"description\": \"A simple Hello World plugin demonstrating QtPlugin basics\",\n    \"author\": \"Your Name\",\n    \"license\": \"MIT\",\n    \"qtplugin_version\": \"3.0.0\",\n    \"qt_version\": \"6.0.0\",\n    \"tags\": [\"example\", \"tutorial\", \"hello-world\"],\n    \"capabilities\": [\"service\"],\n    \"dependencies\": [],\n    \"custom_data\": {\n        \"category\": \"Examples\",\n        \"documentation_url\": \"https://example.com/docs\"\n    }\n}\n</code></pre>"},{"location":"getting-started/first-plugin/#step-3-plugin-header","title":"Step 3: Plugin Header","text":""},{"location":"getting-started/first-plugin/#includehello_pluginhpp","title":"include/hello_plugin.hpp","text":"<pre><code>#pragma once\n\n#include &lt;qtplugin/core/plugin_interface.hpp&gt;\n#include &lt;QObject&gt;\n#include &lt;QJsonObject&gt;\n#include &lt;QElapsedTimer&gt;\n#include &lt;memory&gt;\n\nclass HelloPlugin : public QObject, public qtplugin::IPlugin\n{\n    Q_OBJECT\n    Q_PLUGIN_METADATA(IID \"qtplugin.IPlugin/3.0\" FILE \"metadata.json\")\n    Q_INTERFACES(qtplugin::IPlugin)\n\npublic:\n    explicit HelloPlugin(QObject* parent = nullptr);\n    ~HelloPlugin() override;\n\n    // Lifecycle management\n    qtplugin::expected&lt;void, qtplugin::PluginError&gt; initialize() override;\n    void shutdown() noexcept override;\n    qtplugin::PluginState state() const noexcept override;\n    bool is_initialized() const noexcept override;\n\n    // Metadata and identification\n    qtplugin::PluginMetadata metadata() const override;\n    std::string id() const noexcept override;\n    std::string name() const noexcept override;\n    std::string version() const noexcept override;\n    std::string description() const noexcept override;\n    std::string author() const noexcept override;\n\n    // Configuration management\n    qtplugin::expected&lt;void, qtplugin::PluginError&gt; configure(const QJsonObject&amp; config) override;\n    QJsonObject current_configuration() const override;\n\n    // Command execution\n    qtplugin::expected&lt;QJsonObject, qtplugin::PluginError&gt; execute_command(\n        std::string_view command, \n        const QJsonObject&amp; params = {}\n    ) override;\n\n    // Capability queries\n    std::vector&lt;std::string&gt; supported_commands() const override;\n    bool supports_command(std::string_view command) const override;\n    qtplugin::PluginCapabilities capabilities() const noexcept override;\n\nprivate:\n    // Helper methods\n    void setup_default_configuration();\n    QJsonObject create_hello_response(const QString&amp; name) const;\n    QJsonObject create_status_response() const;\n\n    // Member variables\n    qtplugin::PluginState m_state;\n    bool m_initialized;\n    QJsonObject m_configuration;\n    QElapsedTimer m_uptime_timer;\n    int m_command_count;\n    QString m_greeting_prefix;\n};\n</code></pre>"},{"location":"getting-started/first-plugin/#step-4-plugin-implementation","title":"Step 4: Plugin Implementation","text":""},{"location":"getting-started/first-plugin/#srchello_plugincpp","title":"src/hello_plugin.cpp","text":"<pre><code>#include \"hello_plugin.hpp\"\n#include &lt;QDebug&gt;\n#include &lt;QDateTime&gt;\n#include &lt;QJsonDocument&gt;\n\nHelloPlugin::HelloPlugin(QObject* parent)\n    : QObject(parent)\n    , m_state(qtplugin::PluginState::Unloaded)\n    , m_initialized(false)\n    , m_command_count(0)\n    , m_greeting_prefix(\"Hello\")\n{\n    qDebug() &lt;&lt; \"HelloPlugin: Constructor called\";\n    setup_default_configuration();\n}\n\nHelloPlugin::~HelloPlugin()\n{\n    if (m_initialized) {\n        shutdown();\n    }\n    qDebug() &lt;&lt; \"HelloPlugin: Destructor called\";\n}\n\n// Lifecycle Management\nqtplugin::expected&lt;void, qtplugin::PluginError&gt; HelloPlugin::initialize()\n{\n    if (m_initialized) {\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::AlreadyInitialized,\n            \"Plugin is already initialized\"\n        });\n    }\n\n    try {\n        qDebug() &lt;&lt; \"HelloPlugin: Initializing...\";\n\n        // Start uptime timer\n        m_uptime_timer.start();\n\n        // Reset counters\n        m_command_count = 0;\n\n        // Set state\n        m_initialized = true;\n        m_state = qtplugin::PluginState::Running;\n\n        qDebug() &lt;&lt; \"HelloPlugin: Initialization completed successfully\";\n        return {};\n\n    } catch (const std::exception&amp; e) {\n        m_state = qtplugin::PluginState::Error;\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::InitializationFailed,\n            std::string(\"Initialization failed: \") + e.what()\n        });\n    }\n}\n\nvoid HelloPlugin::shutdown() noexcept\n{\n    try {\n        qDebug() &lt;&lt; \"HelloPlugin: Shutting down...\";\n\n        if (m_initialized) {\n            // Cleanup resources\n            m_command_count = 0;\n            m_initialized = false;\n        }\n\n        m_state = qtplugin::PluginState::Unloaded;\n        qDebug() &lt;&lt; \"HelloPlugin: Shutdown completed\";\n\n    } catch (...) {\n        qWarning() &lt;&lt; \"HelloPlugin: Error during shutdown (ignored)\";\n    }\n}\n\nqtplugin::PluginState HelloPlugin::state() const noexcept\n{\n    return m_state;\n}\n\nbool HelloPlugin::is_initialized() const noexcept\n{\n    return m_initialized;\n}\n\n// Metadata\nqtplugin::PluginMetadata HelloPlugin::metadata() const\n{\n    qtplugin::PluginMetadata meta;\n    meta.id = id();\n    meta.name = name();\n    meta.version = version();\n    meta.description = description();\n    meta.author = author();\n    meta.license = \"MIT\";\n    meta.tags = {\"example\", \"tutorial\", \"hello-world\"};\n    meta.capabilities = capabilities();\n\n    // Custom data\n    meta.custom_data = QJsonObject{\n        {\"category\", \"Examples\"},\n        {\"uptime_ms\", m_uptime_timer.isValid() ? m_uptime_timer.elapsed() : 0},\n        {\"command_count\", m_command_count}\n    };\n\n    return meta;\n}\n\nstd::string HelloPlugin::id() const noexcept\n{\n    return \"com.example.hello-plugin\";\n}\n\nstd::string HelloPlugin::name() const noexcept\n{\n    return \"Hello World Plugin\";\n}\n\nstd::string HelloPlugin::version() const noexcept\n{\n    return \"1.0.0\";\n}\n\nstd::string HelloPlugin::description() const noexcept\n{\n    return \"A simple Hello World plugin demonstrating QtPlugin basics\";\n}\n\nstd::string HelloPlugin::author() const noexcept\n{\n    return \"Your Name\";\n}\n\n// Configuration\nqtplugin::expected&lt;void, qtplugin::PluginError&gt; HelloPlugin::configure(const QJsonObject&amp; config)\n{\n    try {\n        qDebug() &lt;&lt; \"HelloPlugin: Applying configuration...\";\n\n        // Validate configuration\n        if (config.contains(\"greeting_prefix\")) {\n            if (!config[\"greeting_prefix\"].isString()) {\n                return qtplugin::make_unexpected(qtplugin::PluginError{\n                    qtplugin::PluginErrorCode::InvalidConfiguration,\n                    \"greeting_prefix must be a string\"\n                });\n            }\n            m_greeting_prefix = config[\"greeting_prefix\"].toString();\n        }\n\n        // Store configuration\n        m_configuration = config;\n\n        qDebug() &lt;&lt; \"HelloPlugin: Configuration applied successfully\";\n        return {};\n\n    } catch (const std::exception&amp; e) {\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::ConfigurationFailed,\n            std::string(\"Configuration failed: \") + e.what()\n        });\n    }\n}\n\nQJsonObject HelloPlugin::current_configuration() const\n{\n    return m_configuration;\n}\n\n// Command Execution\nqtplugin::expected&lt;QJsonObject, qtplugin::PluginError&gt; HelloPlugin::execute_command(\n    std::string_view command, \n    const QJsonObject&amp; params)\n{\n    if (!m_initialized) {\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::NotInitialized,\n            \"Plugin is not initialized\"\n        });\n    }\n\n    ++m_command_count;\n\n    try {\n        if (command == \"hello\") {\n            QString name = params.value(\"name\").toString(\"World\");\n            return create_hello_response(name);\n\n        } else if (command == \"status\") {\n            return create_status_response();\n\n        } else if (command == \"echo\") {\n            QJsonObject result;\n            result[\"echo\"] = params;\n            result[\"timestamp\"] = QDateTime::currentDateTime().toString(Qt::ISODate);\n            return result;\n\n        } else if (command == \"config\") {\n            return current_configuration();\n\n        } else {\n            return qtplugin::make_unexpected(qtplugin::PluginError{\n                qtplugin::PluginErrorCode::UnknownCommand,\n                std::string(\"Unknown command: \") + std::string(command)\n            });\n        }\n\n    } catch (const std::exception&amp; e) {\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::CommandExecutionFailed,\n            std::string(\"Command execution failed: \") + e.what()\n        });\n    }\n}\n\n// Capabilities\nstd::vector&lt;std::string&gt; HelloPlugin::supported_commands() const\n{\n    return {\"hello\", \"status\", \"echo\", \"config\"};\n}\n\nbool HelloPlugin::supports_command(std::string_view command) const\n{\n    auto commands = supported_commands();\n    return std::find(commands.begin(), commands.end(), command) != commands.end();\n}\n\nqtplugin::PluginCapabilities HelloPlugin::capabilities() const noexcept\n{\n    return qtplugin::PluginCapability::Service | qtplugin::PluginCapability::ThreadSafe;\n}\n\n// Helper Methods\nvoid HelloPlugin::setup_default_configuration()\n{\n    m_configuration = QJsonObject{\n        {\"greeting_prefix\", \"Hello\"},\n        {\"enable_timestamps\", true},\n        {\"max_name_length\", 50}\n    };\n\n    m_greeting_prefix = m_configuration[\"greeting_prefix\"].toString();\n}\n\nQJsonObject HelloPlugin::create_hello_response(const QString&amp; name) const\n{\n    QJsonObject result;\n    result[\"message\"] = QString(\"%1, %2!\").arg(m_greeting_prefix, name);\n    result[\"timestamp\"] = QDateTime::currentDateTime().toString(Qt::ISODate);\n    result[\"plugin_id\"] = QString::fromStdString(id());\n    result[\"command_count\"] = m_command_count;\n\n    return result;\n}\n\nQJsonObject HelloPlugin::create_status_response() const\n{\n    QJsonObject result;\n    result[\"state\"] = static_cast&lt;int&gt;(m_state);\n    result[\"initialized\"] = m_initialized;\n    result[\"uptime_ms\"] = m_uptime_timer.elapsed();\n    result[\"command_count\"] = m_command_count;\n    result[\"plugin_id\"] = QString::fromStdString(id());\n    result[\"version\"] = QString::fromStdString(version());\n\n    return result;\n}\n\n// Include the MOC file\n#include \"hello_plugin.moc\"\n</code></pre>"},{"location":"getting-started/first-plugin/#step-5-build-the-plugin","title":"Step 5: Build the Plugin","text":""},{"location":"getting-started/first-plugin/#build-commands","title":"Build Commands","text":"<pre><code># Create build directory\nmkdir build &amp;&amp; cd build\n\n# Configure\ncmake ..\n\n# Build\ncmake --build .\n\n# Check output\nls -la plugins/\n</code></pre> <p>You should see output like: <pre><code>plugins/\n\u251c\u2500\u2500 hello_plugin.so          # Linux\n\u251c\u2500\u2500 hello_plugin.dll         # Windows\n\u2514\u2500\u2500 hello_plugin.dylib       # macOS\n</code></pre></p>"},{"location":"getting-started/first-plugin/#troubleshooting-build-issues","title":"Troubleshooting Build Issues","text":"<p>If you encounter build errors:</p> <ol> <li> <p>MOC Issues:    <pre><code># Clean and rebuild\nrm -rf build\nmkdir build &amp;&amp; cd build\ncmake .. &amp;&amp; cmake --build .\n</code></pre></p> </li> <li> <p>Missing QtPlugin:    <pre><code># Add to CMakeLists.txt if needed\nfind_package(QtPlugin REQUIRED COMPONENTS Core)\n</code></pre></p> </li> <li> <p>C++20 Issues:    <pre><code># Ensure C++20 is properly set\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n</code></pre></p> </li> </ol>"},{"location":"getting-started/first-plugin/#step-6-test-your-plugin","title":"Step 6: Test Your Plugin","text":""},{"location":"getting-started/first-plugin/#create-test-application","title":"Create Test Application","text":"<p>Create <code>test_hello_plugin.cpp</code>:</p> <pre><code>#include &lt;qtplugin/qtplugin.hpp&gt;\n#include &lt;QCoreApplication&gt;\n#include &lt;QDir&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char *argv[])\n{\n    QCoreApplication app(argc, argv);\n\n    std::cout &lt;&lt; \"=== Testing Hello Plugin ===\" &lt;&lt; std::endl;\n\n    // Initialize QtPlugin\n    qtplugin::LibraryInitializer init;\n    if (!init.is_initialized()) {\n        std::cerr &lt;&lt; \"Failed to initialize QtPlugin\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // Create plugin manager\n    auto manager = qtplugin::PluginManager::create();\n    if (!manager) {\n        std::cerr &lt;&lt; \"Failed to create plugin manager\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // Load the plugin\n    QString plugin_path = QDir::currentPath() + \"/plugins/hello_plugin\";\n#ifdef Q_OS_WIN\n    plugin_path += \".dll\";\n#elif defined(Q_OS_MAC)\n    plugin_path += \".dylib\";\n#else\n    plugin_path += \".so\";\n#endif\n\n    std::cout &lt;&lt; \"Loading plugin: \" &lt;&lt; plugin_path.toStdString() &lt;&lt; std::endl;\n\n    auto result = manager-&gt;load_plugin(plugin_path.toStdString());\n    if (!result) {\n        std::cerr &lt;&lt; \"Failed to load plugin: \" &lt;&lt; result.error().message &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::cout &lt;&lt; \"\u2705 Plugin loaded with ID: \" &lt;&lt; result.value() &lt;&lt; std::endl;\n\n    // Get plugin instance\n    auto plugin = manager-&gt;get_plugin(result.value());\n    if (!plugin) {\n        std::cerr &lt;&lt; \"Failed to get plugin instance\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // Display plugin information\n    std::cout &lt;&lt; \"\\n=== Plugin Information ===\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Name: \" &lt;&lt; plugin-&gt;name() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Version: \" &lt;&lt; plugin-&gt;version() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Description: \" &lt;&lt; plugin-&gt;description() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Author: \" &lt;&lt; plugin-&gt;author() &lt;&lt; std::endl;\n\n    // Initialize plugin\n    auto init_result = plugin-&gt;initialize();\n    if (!init_result) {\n        std::cerr &lt;&lt; \"Failed to initialize plugin: \"\n                  &lt;&lt; init_result.error().message &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::cout &lt;&lt; \"\u2705 Plugin initialized successfully\" &lt;&lt; std::endl;\n\n    // Test commands\n    std::cout &lt;&lt; \"\\n=== Testing Commands ===\" &lt;&lt; std::endl;\n\n    auto commands = plugin-&gt;supported_commands();\n    std::cout &lt;&lt; \"Supported commands: \";\n    for (size_t i = 0; i &lt; commands.size(); ++i) {\n        std::cout &lt;&lt; commands[i];\n        if (i &lt; commands.size() - 1) std::cout &lt;&lt; \", \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    // Test hello command\n    std::cout &lt;&lt; \"\\n1. Testing 'hello' command:\" &lt;&lt; std::endl;\n    QJsonObject hello_params;\n    hello_params[\"name\"] = \"QtPlugin User\";\n\n    auto hello_result = plugin-&gt;execute_command(\"hello\", hello_params);\n    if (hello_result) {\n        QJsonDocument doc(hello_result.value());\n        std::cout &lt;&lt; \"   Result: \" &lt;&lt; doc.toJson(QJsonDocument::Compact).toStdString() &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"   Error: \" &lt;&lt; hello_result.error().message &lt;&lt; std::endl;\n    }\n\n    // Test status command\n    std::cout &lt;&lt; \"\\n2. Testing 'status' command:\" &lt;&lt; std::endl;\n    auto status_result = plugin-&gt;execute_command(\"status\");\n    if (status_result) {\n        QJsonDocument doc(status_result.value());\n        std::cout &lt;&lt; \"   Result: \" &lt;&lt; doc.toJson(QJsonDocument::Compact).toStdString() &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"   Error: \" &lt;&lt; status_result.error().message &lt;&lt; std::endl;\n    }\n\n    // Test configuration\n    std::cout &lt;&lt; \"\\n3. Testing configuration:\" &lt;&lt; std::endl;\n    QJsonObject config;\n    config[\"greeting_prefix\"] = \"Hi\";\n\n    auto config_result = plugin-&gt;configure(config);\n    if (config_result) {\n        std::cout &lt;&lt; \"   \u2705 Configuration applied\" &lt;&lt; std::endl;\n\n        // Test hello again with new configuration\n        auto hello_result2 = plugin-&gt;execute_command(\"hello\", hello_params);\n        if (hello_result2) {\n            QJsonDocument doc(hello_result2.value());\n            std::cout &lt;&lt; \"   New greeting: \" &lt;&lt; doc.toJson(QJsonDocument::Compact).toStdString() &lt;&lt; std::endl;\n        }\n    } else {\n        std::cout &lt;&lt; \"   Error: \" &lt;&lt; config_result.error().message &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; \"\\n=== Test Complete ===\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/first-plugin/#add-test-to-cmakeliststxt","title":"Add Test to CMakeLists.txt","text":"<pre><code># Add test executable\nadd_executable(test_hello_plugin test_hello_plugin.cpp)\ntarget_link_libraries(test_hello_plugin\n    Qt6::Core\n    QtPlugin::Core\n)\n\n# Set output directory\nset_target_properties(test_hello_plugin PROPERTIES\n    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}\n)\n</code></pre>"},{"location":"getting-started/first-plugin/#run-the-test","title":"Run the Test","text":"<pre><code># Build test\ncmake --build .\n\n# Run test\n./test_hello_plugin\n</code></pre> <p>Expected output: <pre><code>=== Testing Hello Plugin ===\nLoading plugin: /path/to/build/plugins/hello_plugin.so\n\u2705 Plugin loaded with ID: com.example.hello-plugin\n\n=== Plugin Information ===\nName: Hello World Plugin\nVersion: 1.0.0\nDescription: A simple Hello World plugin demonstrating QtPlugin basics\nAuthor: Your Name\n\u2705 Plugin initialized successfully\n\n=== Testing Commands ===\nSupported commands: hello, status, echo, config\n\n1. Testing 'hello' command:\n   Result: {\"message\":\"Hello, QtPlugin User!\",\"timestamp\":\"2024-01-15T10:30:45\",\"plugin_id\":\"com.example.hello-plugin\",\"command_count\":1}\n\n2. Testing 'status' command:\n   Result: {\"state\":2,\"initialized\":true,\"uptime_ms\":1234,\"command_count\":2,\"plugin_id\":\"com.example.hello-plugin\",\"version\":\"1.0.0\"}\n\n3. Testing configuration:\n   \u2705 Configuration applied\n   New greeting: {\"message\":\"Hi, QtPlugin User!\",\"timestamp\":\"2024-01-15T10:30:45\",\"plugin_id\":\"com.example.hello-plugin\",\"command_count\":3}\n\n=== Test Complete ===\n</code></pre></p>"},{"location":"getting-started/first-plugin/#step-7-understanding-the-code","title":"Step 7: Understanding the Code","text":""},{"location":"getting-started/first-plugin/#key-concepts-demonstrated","title":"Key Concepts Demonstrated","text":"<ol> <li>Plugin Interface Implementation:</li> <li>All plugins must inherit from <code>qtplugin::IPlugin</code></li> <li> <p>Use Qt's plugin system with <code>Q_OBJECT</code>, <code>Q_PLUGIN_METADATA</code>, and <code>Q_INTERFACES</code></p> </li> <li> <p>Error Handling:</p> </li> <li>Use <code>expected&lt;T, E&gt;</code> for operations that can fail</li> <li> <p>Provide meaningful error messages and codes</p> </li> <li> <p>Lifecycle Management:</p> </li> <li>Proper initialization and shutdown procedures</li> <li> <p>State tracking and validation</p> </li> <li> <p>Command System:</p> </li> <li>Flexible command execution with JSON parameters</li> <li> <p>Type-safe parameter handling</p> </li> <li> <p>Configuration:</p> </li> <li>Dynamic configuration with validation</li> <li>Persistent configuration storage</li> </ol>"},{"location":"getting-started/first-plugin/#best-practices-shown","title":"Best Practices Shown","text":"<ul> <li>RAII: Automatic resource management</li> <li>const correctness: Proper use of const methods</li> <li>Exception safety: Proper exception handling</li> <li>Thread safety: Safe for concurrent access</li> <li>Documentation: Clear code documentation</li> </ul>"},{"location":"getting-started/first-plugin/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've created your first QtPlugin plugin. Here's what to explore next:</p>"},{"location":"getting-started/first-plugin/#enhance-your-plugin","title":"\ud83d\ude80 Enhance Your Plugin","text":"<ol> <li>Add More Commands: Implement additional functionality</li> <li>Persistent Storage: Save data between sessions</li> <li>Background Processing: Add timer-based operations</li> <li>Inter-Plugin Communication: Use the message bus</li> </ol>"},{"location":"getting-started/first-plugin/#learn-more","title":"\ud83d\udcda Learn More","text":"<ol> <li>Developer Guide: Advanced plugin development</li> <li>API Reference: Complete API documentation</li> <li>Examples: More complex examples</li> <li>Best Practices: Production guidelines</li> </ol>"},{"location":"getting-started/first-plugin/#advanced-features","title":"\ud83d\udd27 Advanced Features","text":"<ol> <li>Security: Add plugin validation and permissions</li> <li>Hot Reloading: Support runtime plugin updates</li> <li>Dependencies: Handle plugin dependencies</li> <li>UI Integration: Create plugins with user interfaces</li> </ol>"},{"location":"getting-started/first-plugin/#testing","title":"\ud83e\uddea Testing","text":"<ol> <li>Unit Tests: Write comprehensive tests for your plugin</li> <li>Integration Tests: Test plugin interactions</li> <li>Performance Tests: Optimize plugin performance</li> </ol> <p>Ready to dive deeper? Continue with the Developer Guide for advanced plugin development techniques!</p>"},{"location":"getting-started/installation/","title":"Installation Guide","text":"<p>This guide covers all the ways to install QtPlugin on different platforms and build systems.</p>"},{"location":"getting-started/installation/#quick-installation","title":"Quick Installation","text":""},{"location":"getting-started/installation/#using-package-managers","title":"Using Package Managers","text":"vcpkgConanHomebrew (macOS) <pre><code># Install vcpkg if you haven't already\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh  # Linux/macOS\n# or\n.\\bootstrap-vcpkg.bat  # Windows\n\n# Install QtPlugin\n./vcpkg install qtplugin\n\n# With optional components\n./vcpkg install qtplugin[network,ui,examples]\n</code></pre> <pre><code># Add the remote (if not already added)\nconan remote add qtforge https://api.bintray.com/conan/qtforge/conan\n\n# Install QtPlugin\nconan install qtplugin/3.0.0@qtforge/stable\n\n# With options\nconan install qtplugin/3.0.0@qtforge/stable -o qtplugin:network=True -o qtplugin:ui=True\n</code></pre> <pre><code># Add the tap\nbrew tap qtforge/qtplugin\n\n# Install QtPlugin\nbrew install qtplugin\n\n# With all components\nbrew install qtplugin --with-network --with-ui\n</code></pre>"},{"location":"getting-started/installation/#using-cmake-fetchcontent","title":"Using CMake FetchContent","text":"<p>Add this to your <code>CMakeLists.txt</code>:</p> <pre><code>include(FetchContent)\n\nFetchContent_Declare(\n    QtPlugin\n    GIT_REPOSITORY https://github.com/QtForge/QtPlugin.git\n    GIT_TAG        v3.0.0  # or main for latest\n)\n\nFetchContent_MakeAvailable(QtPlugin)\n\n# Link to your target\ntarget_link_libraries(your_app \n    QtPlugin::Core\n    QtPlugin::Security  # optional\n    QtPlugin::Network   # optional\n    QtPlugin::UI        # optional\n)\n</code></pre>"},{"location":"getting-started/installation/#platform-specific-installation","title":"Platform-Specific Installation","text":""},{"location":"getting-started/installation/#windows","title":"Windows","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ol> <li>Visual Studio 2019 or later (with C++20 support)</li> <li>Qt 6.0+ installed via:</li> <li>Qt Online Installer (recommended)</li> <li>vcpkg: <code>vcpkg install qt6-base qt6-network qt6-widgets</code></li> <li>CMake 3.21+</li> <li>Git for version control</li> </ol>"},{"location":"getting-started/installation/#installation-steps","title":"Installation Steps","text":"Visual StudioMinGW <pre><code># Clone the repository\ngit clone https://github.com/QtForge/QtPlugin.git\ncd QtPlugin\n\n# Create build directory\nmkdir build\ncd build\n\n# Configure with CMake\ncmake .. -G \"Visual Studio 17 2022\" -A x64 ^\n    -DCMAKE_BUILD_TYPE=Release ^\n    -DQTPLUGIN_BUILD_EXAMPLES=ON ^\n    -DQTPLUGIN_BUILD_TESTS=ON\n\n# Build\ncmake --build . --config Release\n\n# Install\ncmake --install . --prefix \"C:\\QtPlugin\"\n</code></pre> <pre><code># Using MSYS2/MinGW64\npacman -S mingw-w64-x86_64-cmake mingw-w64-x86_64-qt6-base\n\n# Clone and build\ngit clone https://github.com/QtForge/QtPlugin.git\ncd QtPlugin\nmkdir build &amp;&amp; cd build\n\ncmake .. -G \"MinGW Makefiles\" \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DQTPLUGIN_BUILD_EXAMPLES=ON\n\ncmake --build .\ncmake --install . --prefix /mingw64\n</code></pre>"},{"location":"getting-started/installation/#windows-specific-notes","title":"Windows-Specific Notes","text":"<ul> <li>Qt Path: Ensure Qt is in your PATH or set <code>Qt6_DIR</code></li> <li>MSVC Runtime: Use <code>/MD</code> for release builds (default)</li> <li>DLL Dependencies: QtPlugin builds as static libraries by default</li> </ul>"},{"location":"getting-started/installation/#linux","title":"Linux","text":""},{"location":"getting-started/installation/#prerequisites_1","title":"Prerequisites","text":"Ubuntu/DebianCentOS/RHEL/FedoraArch Linux <pre><code># Install dependencies\nsudo apt update\nsudo apt install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    qt6-base-dev \\\n    qt6-tools-dev \\\n    libqt6core6 \\\n    libqt6network6 \\\n    libqt6widgets6\n\n# Optional: for network/UI components\nsudo apt install -y \\\n    qt6-networkauth-dev \\\n    qt6-svg-dev\n</code></pre> <pre><code># Fedora\nsudo dnf install -y \\\n    gcc-c++ \\\n    cmake \\\n    git \\\n    qt6-qtbase-devel \\\n    qt6-qttools-devel \\\n    qt6-qtnetworkauth-devel\n\n# CentOS/RHEL (enable EPEL first)\nsudo yum install -y epel-release\nsudo yum install -y \\\n    gcc-c++ \\\n    cmake3 \\\n    git \\\n    qt6-qtbase-devel\n</code></pre> <pre><code># Install dependencies\nsudo pacman -S \\\n    base-devel \\\n    cmake \\\n    git \\\n    qt6-base \\\n    qt6-tools \\\n    qt6-networkauth \\\n    qt6-svg\n</code></pre>"},{"location":"getting-started/installation/#installation-steps_1","title":"Installation Steps","text":"<pre><code># Clone the repository\ngit clone https://github.com/QtForge/QtPlugin.git\ncd QtPlugin\n\n# Create build directory\nmkdir build &amp;&amp; cd build\n\n# Configure\ncmake .. \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DCMAKE_INSTALL_PREFIX=/usr/local \\\n    -DQTPLUGIN_BUILD_EXAMPLES=ON \\\n    -DQTPLUGIN_BUILD_TESTS=ON \\\n    -DQTPLUGIN_BUILD_NETWORK=ON \\\n    -DQTPLUGIN_BUILD_UI=ON\n\n# Build (use all available cores)\ncmake --build . --parallel $(nproc)\n\n# Run tests (optional)\nctest --output-on-failure\n\n# Install\nsudo cmake --install .\n</code></pre>"},{"location":"getting-started/installation/#linux-specific-notes","title":"Linux-Specific Notes","text":"<ul> <li>pkg-config: QtPlugin installs <code>.pc</code> files for pkg-config integration</li> <li>RPATH: Properly configured for system installation</li> <li>Permissions: Use <code>sudo</code> for system-wide installation</li> </ul>"},{"location":"getting-started/installation/#macos","title":"macOS","text":""},{"location":"getting-started/installation/#prerequisites_2","title":"Prerequisites","text":"<ol> <li> <p>Xcode Command Line Tools:    <pre><code>xcode-select --install\n</code></pre></p> </li> <li> <p>Homebrew (recommended):    <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre></p> </li> <li> <p>Dependencies:    <pre><code>brew install cmake qt6 git\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#installation-steps_2","title":"Installation Steps","text":"<pre><code># Clone the repository\ngit clone https://github.com/QtForge/QtPlugin.git\ncd QtPlugin\n\n# Create build directory\nmkdir build &amp;&amp; cd build\n\n# Configure\ncmake .. \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DCMAKE_INSTALL_PREFIX=/usr/local \\\n    -DCMAKE_OSX_DEPLOYMENT_TARGET=10.15 \\\n    -DQTPLUGIN_BUILD_EXAMPLES=ON \\\n    -DQTPLUGIN_BUILD_TESTS=ON\n\n# Build\ncmake --build . --parallel $(sysctl -n hw.ncpu)\n\n# Run tests\nctest --output-on-failure\n\n# Install\nsudo cmake --install .\n</code></pre>"},{"location":"getting-started/installation/#macos-specific-notes","title":"macOS-Specific Notes","text":"<ul> <li>Deployment Target: Set to macOS 10.15+ for C++20 support</li> <li>Code Signing: May require code signing for distribution</li> <li>Framework: Qt can be installed as frameworks or libraries</li> </ul>"},{"location":"getting-started/installation/#build-configuration-options","title":"Build Configuration Options","text":"<p>QtPlugin provides several CMake options to customize your build:</p>"},{"location":"getting-started/installation/#core-options","title":"Core Options","text":"Option Default Description <code>QTPLUGIN_BUILD_NETWORK</code> <code>AUTO</code> Build network plugin support <code>QTPLUGIN_BUILD_UI</code> <code>AUTO</code> Build UI plugin support <code>QTPLUGIN_BUILD_EXAMPLES</code> <code>ON</code> Build example plugins <code>QTPLUGIN_BUILD_TESTS</code> <code>OFF</code> Build unit tests <code>QTPLUGIN_BUILD_COMPONENT_TESTS</code> <code>OFF</code> Build component-specific tests"},{"location":"getting-started/installation/#advanced-options","title":"Advanced Options","text":"Option Default Description <code>QTPLUGIN_ENABLE_COMPONENT_LOGGING</code> <code>OFF</code> Enable detailed component logging <code>CMAKE_BUILD_TYPE</code> <code>Release</code> Build type (Debug/Release/RelWithDebInfo) <code>BUILD_SHARED_LIBS</code> <code>OFF</code> Build shared libraries instead of static"},{"location":"getting-started/installation/#example-configurations","title":"Example Configurations","text":"Minimal BuildFull Development BuildProduction Build <pre><code>cmake .. \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DQTPLUGIN_BUILD_EXAMPLES=OFF \\\n    -DQTPLUGIN_BUILD_TESTS=OFF \\\n    -DQTPLUGIN_BUILD_NETWORK=OFF \\\n    -DQTPLUGIN_BUILD_UI=OFF\n</code></pre> <pre><code>cmake .. \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DQTPLUGIN_BUILD_EXAMPLES=ON \\\n    -DQTPLUGIN_BUILD_TESTS=ON \\\n    -DQTPLUGIN_BUILD_COMPONENT_TESTS=ON \\\n    -DQTPLUGIN_BUILD_NETWORK=ON \\\n    -DQTPLUGIN_BUILD_UI=ON \\\n    -DQTPLUGIN_ENABLE_COMPONENT_LOGGING=ON\n</code></pre> <pre><code>cmake .. \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DCMAKE_INSTALL_PREFIX=/opt/qtplugin \\\n    -DQTPLUGIN_BUILD_EXAMPLES=ON \\\n    -DQTPLUGIN_BUILD_TESTS=ON \\\n    -DQTPLUGIN_BUILD_NETWORK=ON \\\n    -DQTPLUGIN_BUILD_UI=ON \\\n    -DBUILD_SHARED_LIBS=ON\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>After installation, verify that QtPlugin is working correctly:</p>"},{"location":"getting-started/installation/#1-check-installation","title":"1. Check Installation","text":"find_packagepkg-config <p>Create a test <code>CMakeLists.txt</code>:</p> <pre><code>cmake_minimum_required(VERSION 3.21)\nproject(QtPluginTest)\n\nfind_package(QtPlugin REQUIRED COMPONENTS Core)\n\nadd_executable(test_qtplugin main.cpp)\ntarget_link_libraries(test_qtplugin QtPlugin::Core)\n</code></pre> <pre><code># Check if pkg-config can find QtPlugin\npkg-config --exists qtplugin &amp;&amp; echo \"QtPlugin found\" || echo \"QtPlugin not found\"\n\n# Get version\npkg-config --modversion qtplugin\n\n# Get compile flags\npkg-config --cflags qtplugin\n\n# Get link flags\npkg-config --libs qtplugin\n</code></pre>"},{"location":"getting-started/installation/#2-test-basic-functionality","title":"2. Test Basic Functionality","text":"<p>Create a simple test program:</p> main.cpp<pre><code>#include &lt;qtplugin/qtplugin.hpp&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Test library initialization\n    qtplugin::LibraryInitializer init;\n    if (!init.is_initialized()) {\n        std::cerr &lt;&lt; \"Failed to initialize QtPlugin library\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::cout &lt;&lt; \"QtPlugin library initialized successfully!\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Version: \" &lt;&lt; qtplugin::version_string() &lt;&lt; std::endl;\n\n    // Test plugin manager creation\n    auto manager = qtplugin::PluginManager::create();\n    if (!manager) {\n        std::cerr &lt;&lt; \"Failed to create plugin manager\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::cout &lt;&lt; \"Plugin manager created successfully!\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Build and run:</p> <pre><code>mkdir test_build &amp;&amp; cd test_build\ncmake ..\ncmake --build .\n./test_qtplugin\n</code></pre> <p>Expected output: <pre><code>QtPlugin library initialized successfully!\nVersion: 3.0.0\nPlugin manager created successfully!\n</code></pre></p>"},{"location":"getting-started/installation/#3-run-example-programs","title":"3. Run Example Programs","text":"<p>If you built with examples:</p> <pre><code># Navigate to build directory\ncd build\n\n# Run basic plugin example\n./examples/basic_plugin/test_basic_plugin\n\n# Run plugin manager demo\n./examples/plugin_manager_demo --help\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/installation/#qt-not-found","title":"Qt Not Found","text":"<p>Problem: CMake cannot find Qt6</p> <p>Solutions:</p> Set Qt6_DIRAdd to PATH <pre><code># Find your Qt installation\nfind /usr -name \"Qt6Config.cmake\" 2&gt;/dev/null\n# or on Windows\ndir /s Qt6Config.cmake\n\n# Set Qt6_DIR\ncmake .. -DQt6_DIR=/path/to/qt6/lib/cmake/Qt6\n</code></pre> <pre><code># Linux/macOS\nexport PATH=\"/path/to/qt6/bin:$PATH\"\nexport CMAKE_PREFIX_PATH=\"/path/to/qt6:$CMAKE_PREFIX_PATH\"\n\n# Windows\nset PATH=C:\\Qt\\6.5.0\\msvc2019_64\\bin;%PATH%\nset CMAKE_PREFIX_PATH=C:\\Qt\\6.5.0\\msvc2019_64;%CMAKE_PREFIX_PATH%\n</code></pre>"},{"location":"getting-started/installation/#compiler-issues","title":"Compiler Issues","text":"<p>Problem: C++20 features not available</p> <p>Solutions:</p> <ul> <li>GCC: Use GCC 10 or later</li> <li>Clang: Use Clang 12 or later</li> <li>MSVC: Use Visual Studio 2019 16.8 or later</li> </ul> <pre><code># Check compiler version\ngcc --version\nclang --version\n# Windows: check Visual Studio version in IDE\n</code></pre>"},{"location":"getting-started/installation/#cmake-version","title":"CMake Version","text":"<p>Problem: CMake version too old</p> <p>Solution: Install CMake 3.21+</p> LinuxmacOSWindows <pre><code># Remove old version\nsudo apt remove cmake\n\n# Install from Kitware APT repository\nwget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2&gt;/dev/null | gpg --dearmor - | sudo tee /etc/apt/trusted.gpg.d/kitware.gpg &gt;/dev/null\nsudo apt-add-repository 'deb https://apt.kitware.com/ubuntu/ focal main'\nsudo apt update\nsudo apt install cmake\n</code></pre> <pre><code>brew install cmake\n</code></pre> <p>Download from cmake.org or use: <pre><code>winget install Kitware.CMake\n</code></pre></p>"},{"location":"getting-started/installation/#build-failures","title":"Build Failures","text":""},{"location":"getting-started/installation/#missing-dependencies","title":"Missing Dependencies","text":"<p>Check that all required dependencies are installed:</p> <pre><code># Verify Qt installation\nqmake --version  # or qmake6 --version\n\n# Check CMake\ncmake --version\n\n# Verify compiler\ng++ --version    # or clang++ --version\n</code></pre>"},{"location":"getting-started/installation/#permission-issues","title":"Permission Issues","text":"<p>On Linux/macOS, you might need to adjust permissions:</p> <pre><code># Make sure you have write permissions to install directory\nsudo chown -R $USER:$USER /usr/local/include/qtplugin\nsudo chown -R $USER:$USER /usr/local/lib/libqtplugin*\n</code></pre>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you're still having issues:</p> <ol> <li>Check the FAQ for common questions</li> <li>Search GitHub Issues for similar problems</li> <li>Create a new issue with:</li> <li>Your operating system and version</li> <li>Qt version</li> <li>Compiler version</li> <li>CMake version</li> <li>Complete error messages</li> <li>Steps to reproduce</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that QtPlugin is installed, you're ready to:</p> <ol> <li>Quick Start - Create your first QtPlugin application</li> <li>First Plugin - Build your first plugin</li> <li>Examples - Explore working examples</li> </ol>"},{"location":"getting-started/installation/#alternative-installation-methods","title":"Alternative Installation Methods","text":""},{"location":"getting-started/installation/#docker","title":"Docker","text":"<p>For containerized development:</p> <pre><code>FROM ubuntu:22.04\n\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    qt6-base-dev \\\n    qt6-tools-dev\n\nWORKDIR /app\nCOPY . .\n\nRUN mkdir build &amp;&amp; cd build &amp;&amp; \\\n    cmake .. -DCMAKE_BUILD_TYPE=Release &amp;&amp; \\\n    cmake --build . &amp;&amp; \\\n    cmake --install .\n</code></pre>"},{"location":"getting-started/installation/#automated-scripts","title":"Automated Scripts","text":"<p>QtPlugin provides automated installation scripts:</p> Linux/macOSWindows (PowerShell) <pre><code>curl -sSL https://raw.githubusercontent.com/QtForge/QtPlugin/main/scripts/install.sh | bash\n</code></pre> <pre><code>iex ((New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/QtForge/QtPlugin/main/scripts/install.ps1'))\n</code></pre> <p>These scripts will: - Detect your system and install dependencies - Download and build QtPlugin - Install to appropriate system locations - Verify the installation</p>"},{"location":"getting-started/overview/","title":"Getting Started with QtPlugin","text":"<p>Welcome to QtPlugin! This guide will help you understand what QtPlugin is, why you should use it, and how to get started quickly.</p>"},{"location":"getting-started/overview/#what-is-qtplugin","title":"What is QtPlugin?","text":"<p>QtPlugin is a modern, enterprise-grade C++ plugin system designed specifically for Qt applications. It provides a robust, type-safe, and performant way to add extensibility to your applications through dynamic plugin loading.</p>"},{"location":"getting-started/overview/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>\ud83d\ude80 Pure C++: No QML dependencies, works in any C++ application</li> <li>\ud83d\udd27 Modern Standards: Built with C++20 features (concepts, coroutines, <code>std::expected</code>)</li> <li>\ud83d\udee1\ufe0f Type Safe: Compile-time validation and runtime safety</li> <li>\ud83d\udce6 Minimal Dependencies: Core library only requires Qt6::Core</li> <li>\ud83c\udfd7\ufe0f Modular: Optional components for network, UI, and security</li> <li>\u26a1 High Performance: Optimized for speed and memory efficiency</li> </ul>"},{"location":"getting-started/overview/#why-choose-qtplugin","title":"Why Choose QtPlugin?","text":""},{"location":"getting-started/overview/#for-application-developers","title":"\ud83c\udfaf For Application Developers","text":"<ul> <li>Easy Integration: Simple API that integrates seamlessly with Qt applications</li> <li>Flexible Architecture: Support for various plugin types (services, UI components, processors)</li> <li>Hot Reloading: Update plugins without restarting your application</li> <li>Security: Built-in validation and sandboxing capabilities</li> </ul>"},{"location":"getting-started/overview/#for-plugin-developers","title":"\ud83d\udee0\ufe0f For Plugin Developers","text":"<ul> <li>Clear Interface: Well-defined plugin interface with comprehensive documentation</li> <li>Modern C++: Use latest C++ features and best practices</li> <li>Rich Ecosystem: Access to Qt's extensive library ecosystem</li> <li>Development Tools: CMake helpers and development utilities</li> </ul>"},{"location":"getting-started/overview/#for-enterprise","title":"\ud83c\udfe2 For Enterprise","text":"<ul> <li>Production Ready: Thoroughly tested with 100% test coverage</li> <li>Security First: Multi-layer security with configurable trust levels</li> <li>Performance: Optimized for high-throughput scenarios</li> <li>Support: Comprehensive documentation and community support</li> </ul>"},{"location":"getting-started/overview/#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TB\n    App[Your Application] --&gt; PM[Plugin Manager]\n    PM --&gt; PL[Plugin Loader]\n    PM --&gt; PR[Plugin Registry]\n    PM --&gt; SM[Security Manager]\n\n    PL --&gt; P1[Plugin 1]\n    PL --&gt; P2[Plugin 2]\n    PL --&gt; P3[Plugin N...]\n\n    P1 --&gt; MB[Message Bus]\n    P2 --&gt; MB\n    P3 --&gt; MB\n\n    SM --&gt; PV[Plugin Validator]\n    SM --&gt; TM[Trust Manager]\n\n    subgraph \"Core Components\"\n        PM\n        PL\n        PR\n        SM\n    end\n\n    subgraph \"Communication\"\n        MB\n    end\n\n    subgraph \"Security\"\n        PV\n        TM\n    end</code></pre>"},{"location":"getting-started/overview/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/overview/#plugin-interface","title":"Plugin Interface","text":"<p>All plugins implement the <code>qtplugin::IPlugin</code> interface, which provides:</p> <ul> <li>Lifecycle Management: Initialize, shutdown, and state management</li> <li>Metadata: Plugin information and capabilities</li> <li>Command Execution: Execute plugin-specific commands</li> <li>Configuration: Dynamic configuration management</li> </ul>"},{"location":"getting-started/overview/#plugin-manager","title":"Plugin Manager","text":"<p>The central component that handles:</p> <ul> <li>Loading/Unloading: Dynamic plugin lifecycle management</li> <li>Discovery: Automatic plugin discovery and registration</li> <li>Communication: Inter-plugin message routing</li> <li>Security: Validation and trust management</li> </ul>"},{"location":"getting-started/overview/#message-bus","title":"Message Bus","text":"<p>Enables communication between plugins:</p> <ul> <li>Type-Safe Messaging: Strongly-typed message system</li> <li>Asynchronous Communication: Non-blocking message passing</li> <li>Event Broadcasting: Publish-subscribe pattern support</li> <li>Request-Response: Synchronous communication when needed</li> </ul>"},{"location":"getting-started/overview/#system-requirements","title":"System Requirements","text":""},{"location":"getting-started/overview/#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>Operating System: Windows 10+, Linux (Ubuntu 20.04+), macOS 10.15+</li> <li>Qt Version: Qt 6.0 or later</li> <li>Compiler: C++20 compatible compiler</li> <li>GCC 10+ (Linux)</li> <li>Clang 12+ (macOS/Linux)</li> <li>MSVC 2019+ (Windows)</li> <li>CMake: 3.21 or later</li> </ul>"},{"location":"getting-started/overview/#recommended-setup","title":"Recommended Setup","text":"<ul> <li>Qt Version: Qt 6.5+ for best compatibility</li> <li>Build System: Ninja for faster builds</li> <li>IDE: Qt Creator, Visual Studio, or CLion</li> <li>Memory: 4GB+ RAM for development</li> <li>Storage: 2GB+ free space for build artifacts</li> </ul>"},{"location":"getting-started/overview/#component-overview","title":"Component Overview","text":""},{"location":"getting-started/overview/#core-components-always-available","title":"Core Components (Always Available)","text":"Component Description Dependencies QtPlugin::Core Essential plugin management Qt6::Core QtPlugin::Security Plugin validation and security Qt6::Core"},{"location":"getting-started/overview/#optional-components","title":"Optional Components","text":"Component Description Dependencies QtPlugin::Network Network plugin interfaces Qt6::Network QtPlugin::UI UI plugin interfaces Qt6::Widgets"},{"location":"getting-started/overview/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, let's get QtPlugin installed and running:</p> <ol> <li>Installation - Install QtPlugin on your system</li> <li>Quick Start - Create your first QtPlugin application</li> <li>First Plugin - Build your first plugin</li> </ol>"},{"location":"getting-started/overview/#learning-path","title":"Learning Path","text":""},{"location":"getting-started/overview/#beginner-path","title":"\ud83c\udfaf Beginner Path","text":"<ol> <li>Installation - Get QtPlugin installed</li> <li>Quick Start - Basic usage example</li> <li>First Plugin - Create your first plugin</li> <li>Examples - Explore working examples</li> </ol>"},{"location":"getting-started/overview/#intermediate-path","title":"\ud83d\ude80 Intermediate Path","text":"<ol> <li>Plugin Development - Comprehensive plugin creation</li> <li>API Reference - Detailed API documentation</li> <li>Advanced Patterns - Advanced techniques</li> </ol>"},{"location":"getting-started/overview/#advanced-path","title":"\ud83c\udfc6 Advanced Path","text":"<ol> <li>Architecture - System design deep dive</li> <li>Contributing - Contribute to the project</li> <li>Best Practices - Production guidelines</li> </ol>"},{"location":"getting-started/overview/#getting-help","title":"Getting Help","text":"<ul> <li>\ud83d\udcd6 Documentation: Browse this comprehensive documentation</li> <li>\ud83d\udca1 Examples: Check out the examples directory</li> <li>\ud83d\udc1b Issues: Report bugs on GitHub Issues</li> <li>\ud83d\udcac Discussions: Ask questions on GitHub Discussions</li> </ul> <p>Ready to install QtPlugin? Let's move on to the Installation Guide!</p>"},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":"<p>This guide will get you up and running with QtPlugin in just a few minutes. We'll create a simple application that loads and uses a plugin.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have:</p> <ul> <li>\u2705 QtPlugin installed (see Installation Guide)</li> <li>\u2705 Qt 6.0+ with Core module</li> <li>\u2705 C++20 compatible compiler</li> <li>\u2705 CMake 3.21+</li> </ul>"},{"location":"getting-started/quick-start/#step-1-create-your-first-application","title":"Step 1: Create Your First Application","text":"<p>Let's create a simple application that demonstrates QtPlugin's core functionality.</p>"},{"location":"getting-started/quick-start/#project-structure","title":"Project Structure","text":"<p>Create the following directory structure:</p> <pre><code>my_qtplugin_app/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 main.cpp\n\u2514\u2500\u2500 plugins/\n    \u2514\u2500\u2500 (we'll add plugins here later)\n</code></pre>"},{"location":"getting-started/quick-start/#cmakeliststxt","title":"CMakeLists.txt","text":"<pre><code>cmake_minimum_required(VERSION 3.21)\nproject(MyQtPluginApp VERSION 1.0.0 LANGUAGES CXX)\n\n# Set C++20 standard\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# Find Qt6 and QtPlugin\nfind_package(Qt6 REQUIRED COMPONENTS Core)\nfind_package(QtPlugin REQUIRED COMPONENTS Core Security)\n\n# Create the executable\nadd_executable(my_app main.cpp)\n\n# Link libraries\ntarget_link_libraries(my_app\n    Qt6::Core\n    QtPlugin::Core\n    QtPlugin::Security\n)\n\n# Set output directory\nset_target_properties(my_app PROPERTIES\n    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin\n)\n</code></pre>"},{"location":"getting-started/quick-start/#maincpp","title":"main.cpp","text":"<pre><code>#include &lt;qtplugin/qtplugin.hpp&gt;\n#include &lt;QCoreApplication&gt;\n#include &lt;QDir&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char *argv[])\n{\n    QCoreApplication app(argc, argv);\n\n    std::cout &lt;&lt; \"=== QtPlugin Quick Start Demo ===\" &lt;&lt; std::endl;\n\n    // Step 1: Initialize QtPlugin library\n    std::cout &lt;&lt; \"1. Initializing QtPlugin library...\" &lt;&lt; std::endl;\n    qtplugin::LibraryInitializer init;\n    if (!init.is_initialized()) {\n        std::cerr &lt;&lt; \"\u274c Failed to initialize QtPlugin library\" &lt;&lt; std::endl;\n        return -1;\n    }\n    std::cout &lt;&lt; \"\u2705 QtPlugin library initialized (version \" \n              &lt;&lt; qtplugin::version_string() &lt;&lt; \")\" &lt;&lt; std::endl;\n\n    // Step 2: Create plugin manager\n    std::cout &lt;&lt; \"\\n2. Creating plugin manager...\" &lt;&lt; std::endl;\n    auto manager = qtplugin::PluginManager::create();\n    if (!manager) {\n        std::cerr &lt;&lt; \"\u274c Failed to create plugin manager\" &lt;&lt; std::endl;\n        return -1;\n    }\n    std::cout &lt;&lt; \"\u2705 Plugin manager created successfully\" &lt;&lt; std::endl;\n\n    // Step 3: Set up plugin directory\n    QString pluginDir = QDir::currentPath() + \"/plugins\";\n    std::cout &lt;&lt; \"\\n3. Looking for plugins in: \" &lt;&lt; pluginDir.toStdString() &lt;&lt; std::endl;\n\n    // Step 4: Discover plugins\n    QDir dir(pluginDir);\n    if (!dir.exists()) {\n        std::cout &lt;&lt; \"\u26a0\ufe0f  Plugin directory doesn't exist yet\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"   Create some plugins using the 'First Plugin' guide!\" &lt;&lt; std::endl;\n    } else {\n        auto pluginFiles = dir.entryList(QStringList() &lt;&lt; \"*.so\" &lt;&lt; \"*.dll\" &lt;&lt; \"*.dylib\", \n                                        QDir::Files);\n\n        if (pluginFiles.isEmpty()) {\n            std::cout &lt;&lt; \"\u26a0\ufe0f  No plugin files found\" &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"   Create some plugins using the 'First Plugin' guide!\" &lt;&lt; std::endl;\n        } else {\n            std::cout &lt;&lt; \"\ud83d\udce6 Found \" &lt;&lt; pluginFiles.size() &lt;&lt; \" plugin file(s):\" &lt;&lt; std::endl;\n\n            // Step 5: Load each plugin\n            for (const QString&amp; fileName : pluginFiles) {\n                QString fullPath = dir.absoluteFilePath(fileName);\n                std::cout &lt;&lt; \"\\n5. Loading plugin: \" &lt;&lt; fileName.toStdString() &lt;&lt; std::endl;\n\n                auto result = manager-&gt;load_plugin(fullPath.toStdString());\n                if (!result) {\n                    std::cerr &lt;&lt; \"\u274c Failed to load plugin: \" \n                              &lt;&lt; result.error().message &lt;&lt; std::endl;\n                    continue;\n                }\n\n                std::cout &lt;&lt; \"\u2705 Plugin loaded with ID: \" &lt;&lt; result.value() &lt;&lt; std::endl;\n\n                // Step 6: Get plugin information\n                auto plugin = manager-&gt;get_plugin(result.value());\n                if (plugin) {\n                    std::cout &lt;&lt; \"   Name: \" &lt;&lt; plugin-&gt;name() &lt;&lt; std::endl;\n                    std::cout &lt;&lt; \"   Version: \" &lt;&lt; plugin-&gt;version() &lt;&lt; std::endl;\n                    std::cout &lt;&lt; \"   Description: \" &lt;&lt; plugin-&gt;description() &lt;&lt; std::endl;\n\n                    // Step 7: Initialize the plugin\n                    auto init_result = plugin-&gt;initialize();\n                    if (init_result) {\n                        std::cout &lt;&lt; \"\u2705 Plugin initialized successfully\" &lt;&lt; std::endl;\n\n                        // Step 8: Execute a command (if supported)\n                        auto commands = plugin-&gt;supported_commands();\n                        if (!commands.empty()) {\n                            std::cout &lt;&lt; \"   Available commands: \";\n                            for (size_t i = 0; i &lt; commands.size(); ++i) {\n                                std::cout &lt;&lt; commands[i];\n                                if (i &lt; commands.size() - 1) std::cout &lt;&lt; \", \";\n                            }\n                            std::cout &lt;&lt; std::endl;\n\n                            // Try to execute the first command\n                            auto cmd_result = plugin-&gt;execute_command(commands[0]);\n                            if (cmd_result) {\n                                std::cout &lt;&lt; \"\u2705 Command '\" &lt;&lt; commands[0] \n                                          &lt;&lt; \"' executed successfully\" &lt;&lt; std::endl;\n                            }\n                        }\n                    } else {\n                        std::cerr &lt;&lt; \"\u274c Failed to initialize plugin: \" \n                                  &lt;&lt; init_result.error().message &lt;&lt; std::endl;\n                    }\n                }\n            }\n        }\n    }\n\n    std::cout &lt;&lt; \"\\n=== Demo Complete ===\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Next steps:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"1. Create your first plugin: see 'First Plugin' guide\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"2. Explore examples: see 'Examples' section\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"3. Read the API documentation for advanced usage\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/quick-start/#step-2-build-and-run","title":"Step 2: Build and Run","text":""},{"location":"getting-started/quick-start/#build-the-application","title":"Build the Application","text":"<pre><code># Create build directory\nmkdir build &amp;&amp; cd build\n\n# Configure\ncmake ..\n\n# Build\ncmake --build .\n\n# Create plugins directory\nmkdir -p bin/plugins\n</code></pre>"},{"location":"getting-started/quick-start/#run-the-application","title":"Run the Application","text":"<pre><code># Run the application\n./bin/my_app\n</code></pre> <p>You should see output like:</p> <pre><code>=== QtPlugin Quick Start Demo ===\n1. Initializing QtPlugin library...\n\u2705 QtPlugin library initialized (version 3.0.0)\n\n2. Creating plugin manager...\n\u2705 Plugin manager created successfully\n\n3. Looking for plugins in: /path/to/your/app/build/bin/plugins\n\u26a0\ufe0f  No plugin files found\n   Create some plugins using the 'First Plugin' guide!\n\n=== Demo Complete ===\nNext steps:\n1. Create your first plugin: see 'First Plugin' guide\n2. Explore examples: see 'Examples' section\n3. Read the API documentation for advanced usage\n</code></pre>"},{"location":"getting-started/quick-start/#step-3-understanding-the-code","title":"Step 3: Understanding the Code","text":"<p>Let's break down what the code does:</p>"},{"location":"getting-started/quick-start/#1-library-initialization","title":"1. Library Initialization","text":"<pre><code>qtplugin::LibraryInitializer init;\n</code></pre> <p>This initializes the QtPlugin library and sets up internal systems. Always do this first!</p>"},{"location":"getting-started/quick-start/#2-plugin-manager-creation","title":"2. Plugin Manager Creation","text":"<pre><code>auto manager = qtplugin::PluginManager::create();\n</code></pre> <p>The plugin manager is the central component that handles all plugin operations.</p>"},{"location":"getting-started/quick-start/#3-plugin-loading","title":"3. Plugin Loading","text":"<pre><code>auto result = manager-&gt;load_plugin(fullPath.toStdString());\n</code></pre> <p>This loads a plugin from a file. The result is either a plugin ID or an error.</p>"},{"location":"getting-started/quick-start/#4-plugin-access","title":"4. Plugin Access","text":"<pre><code>auto plugin = manager-&gt;get_plugin(result.value());\n</code></pre> <p>Get a reference to the loaded plugin using its ID.</p>"},{"location":"getting-started/quick-start/#5-plugin-initialization","title":"5. Plugin Initialization","text":"<pre><code>auto init_result = plugin-&gt;initialize();\n</code></pre> <p>Initialize the plugin so it's ready to use.</p>"},{"location":"getting-started/quick-start/#6-command-execution","title":"6. Command Execution","text":"<pre><code>auto cmd_result = plugin-&gt;execute_command(commands[0]);\n</code></pre> <p>Execute plugin-specific commands.</p>"},{"location":"getting-started/quick-start/#step-4-error-handling","title":"Step 4: Error Handling","text":"<p>QtPlugin uses the modern <code>expected&lt;T, E&gt;</code> pattern for error handling:</p> <pre><code>// Check if operation succeeded\nif (result) {\n    // Success - use result.value()\n    std::cout &lt;&lt; \"Success: \" &lt;&lt; result.value() &lt;&lt; std::endl;\n} else {\n    // Error - use result.error()\n    std::cerr &lt;&lt; \"Error: \" &lt;&lt; result.error().message &lt;&lt; std::endl;\n}\n</code></pre> <p>This provides: - Type Safety: Compile-time error checking - No Exceptions: Explicit error handling - Performance: Zero-cost abstractions</p>"},{"location":"getting-started/quick-start/#step-5-next-steps","title":"Step 5: Next Steps","text":"<p>Now that you have a working QtPlugin application:</p>"},{"location":"getting-started/quick-start/#create-your-first-plugin","title":"Create Your First Plugin","text":"<p>Follow the First Plugin Guide to create a simple plugin that your application can load.</p>"},{"location":"getting-started/quick-start/#explore-examples","title":"Explore Examples","text":"<p>Check out the Examples to see more sophisticated usage patterns:</p> <ul> <li>Basic Plugin: Simple plugin with commands</li> <li>Service Plugin: Background processing</li> <li>Network Plugin: Network-enabled plugins</li> <li>UI Plugin: Plugins with user interfaces</li> </ul>"},{"location":"getting-started/quick-start/#learn-more","title":"Learn More","text":"<ul> <li>User Guide: Comprehensive usage guide</li> <li>API Reference: Complete API documentation</li> <li>Developer Guide: Advanced plugin development</li> </ul>"},{"location":"getting-started/quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quick-start/#plugin-discovery","title":"Plugin Discovery","text":"<pre><code>// Automatically discover plugins in a directory\nauto plugins = manager-&gt;discover_plugins(\"/path/to/plugins\");\nfor (const auto&amp; plugin_path : plugins) {\n    auto result = manager-&gt;load_plugin(plugin_path);\n    // Handle result...\n}\n</code></pre>"},{"location":"getting-started/quick-start/#configuration","title":"Configuration","text":"<pre><code>// Configure a plugin\nQJsonObject config;\nconfig[\"setting1\"] = \"value1\";\nconfig[\"setting2\"] = 42;\n\nauto result = plugin-&gt;configure(config);\nif (result) {\n    std::cout &lt;&lt; \"Plugin configured successfully\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"getting-started/quick-start/#cleanup","title":"Cleanup","text":"<pre><code>// Proper cleanup (automatic with RAII)\n{\n    qtplugin::LibraryInitializer init;\n    auto manager = qtplugin::PluginManager::create();\n    // ... use plugins ...\n} // Automatic cleanup when going out of scope\n</code></pre>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quick-start/#plugin-not-loading","title":"Plugin Not Loading","text":"<ol> <li>Check file permissions: Ensure the plugin file is readable</li> <li>Verify dependencies: Make sure all required libraries are available</li> <li>Check architecture: Plugin must match your application's architecture (32/64-bit)</li> <li>Debug symbols: Build in Debug mode for more detailed error messages</li> </ol>"},{"location":"getting-started/quick-start/#initialization-failures","title":"Initialization Failures","text":"<ol> <li>Qt version: Ensure Qt 6.0+ is available</li> <li>Missing components: Check that required Qt modules are installed</li> <li>Permissions: Verify write access to temporary directories</li> </ol>"},{"location":"getting-started/quick-start/#build-issues","title":"Build Issues","text":"<ol> <li>CMake version: Ensure CMake 3.21+ is installed</li> <li>Compiler support: Verify C++20 support in your compiler</li> <li>Qt detection: Set <code>Qt6_DIR</code> if Qt is not found automatically</li> </ol> <p>Ready to create your first plugin? Continue to the First Plugin Guide!</p>"},{"location":"guides/","title":"Guides","text":"<ul> <li>plugin-development.md \u2014 how to build plugins</li> <li>architecture.md \u2014 system design overview</li> </ul>"},{"location":"guides/architecture/","title":"QtPlugin Architecture Guide","text":"<p>This document describes the architecture and design principles of the QtPlugin library.</p>"},{"location":"guides/architecture/#overview","title":"Overview","text":"<p>QtPlugin is designed as a modern, enterprise-grade plugin system that emphasizes: - Type Safety: Compile-time validation using C++20 concepts - Error Handling: Modern error handling without exceptions using expected - Performance: Efficient plugin loading and communication - Security: Plugin validation and sandboxing - Modularity: Clean separation of concerns with dependency injection"},{"location":"guides/architecture/#core-architecture","title":"Core Architecture","text":""},{"location":"guides/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Application Layer                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                    QtPlugin API                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Plugin Manager  \u2502  Message Bus  \u2502  Security Manager       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Resource Mgr    \u2502  Config Mgr   \u2502  Logging Manager        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Plugin Loader   \u2502  Dependency   \u2502  Lifecycle Manager      \u2502\n\u2502                  \u2502  Resolver     \u2502                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                    Qt Framework                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"guides/architecture/#component-relationships","title":"Component Relationships","text":"<pre><code>graph TB\n    App[Application] --&gt; PM[Plugin Manager]\n    PM --&gt; PL[Plugin Loader]\n    PM --&gt; DR[Dependency Resolver]\n    PM --&gt; SM[Security Manager]\n    PM --&gt; RM[Resource Manager]\n    PM --&gt; CM[Configuration Manager]\n    PM --&gt; LM[Logging Manager]\n    PM --&gt; LC[Lifecycle Manager]\n    PM --&gt; MB[Message Bus]\n\n    PL --&gt; Plugin1[Plugin A]\n    PL --&gt; Plugin2[Plugin B]\n    PL --&gt; Plugin3[Plugin C]\n\n    Plugin1 --&gt; MB\n    Plugin2 --&gt; MB\n    Plugin3 --&gt; MB\n\n    RM --&gt; Monitor[Resource Monitor]\n    LC --&gt; Monitor</code></pre>"},{"location":"guides/architecture/#core-components","title":"Core Components","text":""},{"location":"guides/architecture/#plugin-manager","title":"Plugin Manager","text":"<p>The central orchestrator responsible for: - Plugin discovery and loading - Lifecycle management - Dependency resolution - Error handling and recovery - Event coordination</p> <p>Key Design Patterns: - Facade Pattern: Provides simplified interface to complex subsystem - Observer Pattern: Notifies subscribers of plugin events - Factory Pattern: Creates plugin instances through dependency injection</p> <pre><code>class PluginManager {\n    // Composition over inheritance\n    std::unique_ptr&lt;PluginLoader&gt; m_loader;\n    std::unique_ptr&lt;DependencyResolver&gt; m_resolver;\n    std::unique_ptr&lt;SecurityManager&gt; m_security;\n    std::unique_ptr&lt;ResourceManager&gt; m_resources;\n    // ... other managers\n};\n</code></pre>"},{"location":"guides/architecture/#plugin-interface","title":"Plugin Interface","text":"<p>Defines the contract that all plugins must implement:</p> <p>Design Principles: - Interface Segregation: Minimal, focused interface - Dependency Inversion: Plugins depend on abstractions, not concretions - Open/Closed: Open for extension, closed for modification</p> <pre><code>class IPlugin {\n    // Core lifecycle (required)\n    virtual expected&lt;void, PluginError&gt; initialize() = 0;\n    virtual void shutdown() = 0;\n\n    // Metadata (required)\n    virtual PluginMetadata metadata() const = 0;\n\n    // Configuration (optional)\n    virtual expected&lt;void, PluginError&gt; configure(const QJsonObject&amp;) = 0;\n\n    // Command execution (optional)\n    virtual expected&lt;QJsonObject, PluginError&gt; execute_command(...) = 0;\n};\n</code></pre>"},{"location":"guides/architecture/#error-handling-system","title":"Error Handling System","text":"<p>Modern error handling without exceptions:</p> <p>Design Philosophy: - Explicit Error Handling: All errors are explicit in function signatures - Composable: Errors can be chained and transformed - Type Safe: Compile-time error checking - Performance: No exception overhead</p> <pre><code>template&lt;typename T, typename E&gt;\nclass expected {\n    // Monadic operations for error composition\n    template&lt;typename F&gt;\n    auto and_then(F&amp;&amp; f) const -&gt; expected&lt;...&gt;;\n\n    template&lt;typename F&gt;\n    auto or_else(F&amp;&amp; f) const -&gt; expected&lt;T, ...&gt;;\n\n    template&lt;typename F&gt;\n    auto transform(F&amp;&amp; f) const -&gt; expected&lt;...&gt;;\n};\n</code></pre>"},{"location":"guides/architecture/#resource-management","title":"Resource Management","text":"<p>Automatic resource tracking and cleanup:</p> <p>RAII Principles: - Automatic Cleanup: Resources cleaned up when plugins unload - Exception Safety: Strong exception safety guarantees - Leak Prevention: Automatic detection of resource leaks</p> <pre><code>class ResourceManager {\n    // Resource factories for different types\n    std::map&lt;std::string, std::unique_ptr&lt;ResourceFactory&gt;&gt; m_factories;\n\n    // Per-plugin resource tracking\n    std::map&lt;std::string, std::vector&lt;ResourceHandle&gt;&gt; m_plugin_resources;\n\n    // Automatic cleanup on plugin unload\n    void cleanup_plugin_resources(const std::string&amp; plugin_id);\n};\n</code></pre>"},{"location":"guides/architecture/#design-patterns","title":"Design Patterns","text":""},{"location":"guides/architecture/#factory-pattern","title":"Factory Pattern","text":"<p>Used throughout for object creation and dependency injection:</p> <pre><code>// Abstract factory for managers\nclass ManagerFactory {\npublic:\n    virtual std::unique_ptr&lt;ConfigurationManager&gt; create_configuration_manager() = 0;\n    virtual std::unique_ptr&lt;LoggingManager&gt; create_logging_manager() = 0;\n    virtual std::unique_ptr&lt;ResourceManager&gt; create_resource_manager() = 0;\n};\n\n// Concrete factory with dependency injection\nclass DefaultManagerFactory : public ManagerFactory {\n    // Implementations create managers with proper dependencies\n};\n</code></pre>"},{"location":"guides/architecture/#observer-pattern","title":"Observer Pattern","text":"<p>Event notification system:</p> <pre><code>class PluginManager : public QObject {\n    Q_OBJECT\n\nsignals:\n    void plugin_loaded(const QString&amp; plugin_id);\n    void plugin_unloaded(const QString&amp; plugin_id);\n    void plugin_error(const QString&amp; plugin_id, const QString&amp; error);\n\n    // Internal event coordination\nprivate slots:\n    void on_plugin_state_changed(const QString&amp; plugin_id, PluginState state);\n};\n</code></pre>"},{"location":"guides/architecture/#strategy-pattern","title":"Strategy Pattern","text":"<p>Configurable behavior for security, validation, and loading:</p> <pre><code>class SecurityManager {\n    std::unique_ptr&lt;ValidationStrategy&gt; m_validator;\n    std::unique_ptr&lt;SignatureStrategy&gt; m_signature_checker;\n\npublic:\n    void set_validation_strategy(std::unique_ptr&lt;ValidationStrategy&gt; strategy);\n    void set_signature_strategy(std::unique_ptr&lt;SignatureStrategy&gt; strategy);\n};\n</code></pre>"},{"location":"guides/architecture/#command-pattern","title":"Command Pattern","text":"<p>Plugin command execution:</p> <pre><code>class PluginCommand {\npublic:\n    virtual expected&lt;QJsonObject, PluginError&gt; execute(\n        IPlugin* plugin, \n        const QJsonObject&amp; params\n    ) = 0;\n};\n\nclass CommandRegistry {\n    std::map&lt;std::string, std::unique_ptr&lt;PluginCommand&gt;&gt; m_commands;\n\npublic:\n    void register_command(const std::string&amp; name, std::unique_ptr&lt;PluginCommand&gt; cmd);\n    expected&lt;QJsonObject, PluginError&gt; execute_command(\n        const std::string&amp; name, \n        IPlugin* plugin, \n        const QJsonObject&amp; params\n    );\n};\n</code></pre>"},{"location":"guides/architecture/#memory-management","title":"Memory Management","text":""},{"location":"guides/architecture/#smart-pointer-usage","title":"Smart Pointer Usage","text":"<p>Consistent use of smart pointers for automatic memory management:</p> <pre><code>// Ownership semantics\nstd::unique_ptr&lt;T&gt;  // Exclusive ownership\nstd::shared_ptr&lt;T&gt;  // Shared ownership\nstd::weak_ptr&lt;T&gt;    // Non-owning reference\n\n// Plugin storage\nstd::map&lt;std::string, std::shared_ptr&lt;IPlugin&gt;&gt; m_plugins;\n\n// Manager storage\nstd::unique_ptr&lt;PluginLoader&gt; m_loader;  // Exclusive ownership\n</code></pre>"},{"location":"guides/architecture/#raii-principles","title":"RAII Principles","text":"<p>All resources follow RAII:</p> <pre><code>class PluginHandle {\n    std::string m_plugin_id;\n    PluginManager* m_manager;\n\npublic:\n    PluginHandle(const std::string&amp; id, PluginManager* mgr)\n        : m_plugin_id(id), m_manager(mgr) {}\n\n    ~PluginHandle() {\n        if (m_manager) {\n            m_manager-&gt;unload_plugin(m_plugin_id);\n        }\n    }\n\n    // Move-only semantics\n    PluginHandle(const PluginHandle&amp;) = delete;\n    PluginHandle&amp; operator=(const PluginHandle&amp;) = delete;\n    PluginHandle(PluginHandle&amp;&amp;) = default;\n    PluginHandle&amp; operator=(PluginHandle&amp;&amp;) = default;\n};\n</code></pre>"},{"location":"guides/architecture/#thread-safety","title":"Thread Safety","text":""},{"location":"guides/architecture/#synchronization-strategy","title":"Synchronization Strategy","text":"<p>Thread-safe design with minimal locking:</p> <pre><code>class PluginManager {\n    mutable std::shared_mutex m_plugins_mutex;\n    std::map&lt;std::string, std::shared_ptr&lt;IPlugin&gt;&gt; m_plugins;\n\npublic:\n    // Read operations use shared lock\n    std::shared_ptr&lt;IPlugin&gt; get_plugin(const std::string&amp; id) const {\n        std::shared_lock lock(m_plugins_mutex);\n        auto it = m_plugins.find(id);\n        return (it != m_plugins.end()) ? it-&gt;second : nullptr;\n    }\n\n    // Write operations use exclusive lock\n    expected&lt;std::string, PluginError&gt; load_plugin(const std::string&amp; path) {\n        std::unique_lock lock(m_plugins_mutex);\n        // ... loading logic\n    }\n};\n</code></pre>"},{"location":"guides/architecture/#lock-free-operations","title":"Lock-Free Operations","text":"<p>Where possible, use lock-free data structures:</p> <pre><code>// Atomic counters for statistics\nstd::atomic&lt;size_t&gt; m_plugins_loaded{0};\nstd::atomic&lt;size_t&gt; m_commands_executed{0};\n\n// Lock-free message queue for inter-plugin communication\nclass LockFreeMessageQueue {\n    std::atomic&lt;Node*&gt; m_head;\n    std::atomic&lt;Node*&gt; m_tail;\n\npublic:\n    void enqueue(const Message&amp; msg);\n    bool dequeue(Message&amp; msg);\n};\n</code></pre>"},{"location":"guides/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guides/architecture/#plugin-loading-optimization","title":"Plugin Loading Optimization","text":"<ul> <li>Lazy Loading: Plugins loaded on-demand</li> <li>Parallel Loading: Independent plugins loaded concurrently</li> <li>Caching: Metadata cached to avoid repeated file I/O</li> </ul> <pre><code>class PluginLoader {\n    // Metadata cache\n    std::map&lt;std::string, PluginMetadata&gt; m_metadata_cache;\n\n    // Async loading\n    std::future&lt;expected&lt;std::shared_ptr&lt;IPlugin&gt;, PluginError&gt;&gt; \n    load_plugin_async(const std::string&amp; path);\n\n    // Batch loading\n    std::vector&lt;std::future&lt;...&gt;&gt; load_plugins_batch(\n        const std::vector&lt;std::string&gt;&amp; paths\n    );\n};\n</code></pre>"},{"location":"guides/architecture/#memory-optimization","title":"Memory Optimization","text":"<ul> <li>Object Pooling: Reuse objects where appropriate</li> <li>Small String Optimization: Efficient string handling</li> <li>Memory Mapping: For large plugin files</li> </ul>"},{"location":"guides/architecture/#communication-optimization","title":"Communication Optimization","text":"<ul> <li>Message Batching: Batch small messages</li> <li>Zero-Copy: Avoid unnecessary data copying</li> <li>Compression: Compress large messages</li> </ul>"},{"location":"guides/architecture/#security-architecture","title":"Security Architecture","text":""},{"location":"guides/architecture/#defense-in-depth","title":"Defense in Depth","text":"<p>Multiple layers of security:</p> <ol> <li>File System: Plugin file validation</li> <li>Loading: Signature verification</li> <li>Runtime: Sandboxing and capability restrictions</li> <li>Communication: Message validation and filtering</li> </ol> <pre><code>class SecurityManager {\n    // Multi-layer validation\n    expected&lt;void, SecurityError&gt; validate_file(const std::string&amp; path);\n    expected&lt;void, SecurityError&gt; verify_signature(const std::string&amp; path);\n    expected&lt;void, SecurityError&gt; check_capabilities(const PluginMetadata&amp; meta);\n    expected&lt;void, SecurityError&gt; validate_runtime_behavior(IPlugin* plugin);\n};\n</code></pre>"},{"location":"guides/architecture/#capability-based-security","title":"Capability-Based Security","text":"<p>Plugins declare required capabilities:</p> <pre><code>struct PluginCapabilities {\n    bool requires_network = false;\n    bool requires_filesystem = false;\n    bool requires_ui = false;\n    std::vector&lt;std::string&gt; required_permissions;\n};\n</code></pre>"},{"location":"guides/architecture/#extensibility","title":"Extensibility","text":""},{"location":"guides/architecture/#plugin-types","title":"Plugin Types","text":"<p>Support for different plugin types through interfaces:</p> <pre><code>// Base plugin interface\nclass IPlugin { /* ... */ };\n\n// Specialized interfaces\nclass IServicePlugin : public IPlugin { /* ... */ };\nclass IDataProcessorPlugin : public IPlugin { /* ... */ };\nclass INetworkPlugin : public IPlugin { /* ... */ };\nclass IUIPlugin : public IPlugin { /* ... */ };\n</code></pre>"},{"location":"guides/architecture/#custom-managers","title":"Custom Managers","text":"<p>Framework allows custom manager implementations:</p> <pre><code>// Custom configuration manager\nclass DatabaseConfigurationManager : public ConfigurationManager {\n    // Store configuration in database instead of files\n};\n\n// Custom security manager\nclass EnterpriseSecurityManager : public SecurityManager {\n    // Enterprise-specific security policies\n};\n</code></pre>"},{"location":"guides/architecture/#testing-architecture","title":"Testing Architecture","text":""},{"location":"guides/architecture/#testability-design","title":"Testability Design","text":"<ul> <li>Dependency Injection: Easy to mock dependencies</li> <li>Interface-Based: All components behind interfaces</li> <li>Isolated Components: Components can be tested in isolation</li> </ul> <pre><code>// Mock implementations for testing\nclass MockPluginLoader : public PluginLoader {\n    // Controlled plugin loading for tests\n};\n\nclass MockSecurityManager : public SecurityManager {\n    // Configurable security behavior for tests\n};\n</code></pre>"},{"location":"guides/architecture/#test-categories","title":"Test Categories","text":"<ol> <li>Unit Tests: Individual component testing</li> <li>Integration Tests: Component interaction testing</li> <li>Performance Tests: Load and stress testing</li> <li>Security Tests: Vulnerability and penetration testing</li> </ol>"},{"location":"guides/architecture/#future-extensibility","title":"Future Extensibility","text":"<p>The architecture is designed to support future enhancements:</p> <ul> <li>Distributed Plugins: Remote plugin loading and execution</li> <li>Hot Swapping: Runtime plugin replacement</li> <li>Plugin Composition: Combining multiple plugins</li> <li>AI Integration: Machine learning-based plugin recommendations</li> <li>Cloud Integration: Cloud-based plugin repositories</li> </ul>"},{"location":"guides/architecture/#best-practices","title":"Best Practices","text":"<ol> <li>Follow SOLID Principles: Single responsibility, open/closed, etc.</li> <li>Use Modern C++: Leverage C++20 features appropriately</li> <li>Minimize Dependencies: Keep plugin interface minimal</li> <li>Error Handling: Always use expected for fallible operations <li>Resource Management: Follow RAII principles strictly</li> <li>Thread Safety: Design for concurrent access from the start</li> <li>Performance: Profile and optimize critical paths</li> <li>Security: Validate all inputs and implement defense in depth</li> <li>Testing: Write comprehensive tests for all components</li> <li>Documentation: Document all public APIs and design decisions</li>"},{"location":"guides/plugin-development/","title":"Plugin Development Guide","text":"<p>This guide covers everything you need to know to develop plugins for the QtPlugin system.</p>"},{"location":"guides/plugin-development/#getting-started","title":"Getting Started","text":""},{"location":"guides/plugin-development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Qt 6.0 or later</li> <li>C++20 compatible compiler</li> <li>CMake 3.20 or later</li> <li>QtPlugin library installed</li> </ul>"},{"location":"guides/plugin-development/#plugin-structure","title":"Plugin Structure","text":"<p>A typical plugin consists of: - Plugin class: Implements <code>qtplugin::IPlugin</code> interface - Metadata file: JSON file describing the plugin - CMakeLists.txt: Build configuration - Resources: Any additional files needed by the plugin</p>"},{"location":"guides/plugin-development/#creating-your-first-plugin","title":"Creating Your First Plugin","text":""},{"location":"guides/plugin-development/#step-1-plugin-class-implementation","title":"Step 1: Plugin Class Implementation","text":"<p>Create a header file <code>my_plugin.hpp</code>:</p> <pre><code>#pragma once\n\n#include &lt;qtplugin/core/plugin_interface.hpp&gt;\n#include &lt;QObject&gt;\n\nclass MyPlugin : public QObject, public qtplugin::IPlugin {\n    Q_OBJECT\n    Q_PLUGIN_METADATA(IID \"qtplugin.IPlugin/3.0\" FILE \"metadata.json\")\n    Q_INTERFACES(qtplugin::IPlugin)\n\npublic:\n    MyPlugin(QObject* parent = nullptr);\n    ~MyPlugin() override;\n\n    // IPlugin interface implementation\n    qtplugin::expected&lt;void, qtplugin::PluginError&gt; initialize() override;\n    void shutdown() override;\n    qtplugin::PluginState state() const override;\n    bool is_initialized() const override;\n\n    qtplugin::PluginMetadata metadata() const override;\n    std::string id() const override;\n    std::string name() const override;\n    std::string version() const override;\n    std::string description() const override;\n\n    qtplugin::expected&lt;void, qtplugin::PluginError&gt; configure(const QJsonObject&amp; config) override;\n    QJsonObject current_configuration() const override;\n\n    qtplugin::expected&lt;QJsonObject, qtplugin::PluginError&gt; execute_command(\n        std::string_view command, \n        const QJsonObject&amp; params = {}\n    ) override;\n\n    std::vector&lt;std::string&gt; supported_commands() const override;\n    bool supports_command(std::string_view command) const override;\n    qtplugin::PluginCapabilities capabilities() const override;\n\nprivate:\n    qtplugin::PluginState m_state = qtplugin::PluginState::Unloaded;\n    QJsonObject m_configuration;\n    bool m_initialized = false;\n};\n</code></pre>"},{"location":"guides/plugin-development/#step-2-plugin-implementation","title":"Step 2: Plugin Implementation","text":"<p>Create the implementation file <code>my_plugin.cpp</code>:</p> <pre><code>#include \"my_plugin.hpp\"\n#include &lt;QDebug&gt;\n#include &lt;QJsonDocument&gt;\n\nMyPlugin::MyPlugin(QObject* parent)\n    : QObject(parent)\n{\n    qDebug() &lt;&lt; \"MyPlugin constructor called\";\n}\n\nMyPlugin::~MyPlugin()\n{\n    if (m_initialized) {\n        shutdown();\n    }\n    qDebug() &lt;&lt; \"MyPlugin destructor called\";\n}\n\nqtplugin::expected&lt;void, qtplugin::PluginError&gt; MyPlugin::initialize()\n{\n    if (m_initialized) {\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::InitializationFailed,\n            \"Plugin already initialized\"\n        });\n    }\n\n    try {\n        // Perform initialization logic here\n        qDebug() &lt;&lt; \"Initializing MyPlugin...\";\n\n        // Example: Setup internal state, connect to services, etc.\n        m_state = qtplugin::PluginState::Running;\n        m_initialized = true;\n\n        qDebug() &lt;&lt; \"MyPlugin initialized successfully\";\n        return {};\n    }\n    catch (const std::exception&amp; e) {\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::InitializationFailed,\n            std::string(\"Initialization failed: \") + e.what()\n        });\n    }\n}\n\nvoid MyPlugin::shutdown()\n{\n    if (!m_initialized) {\n        return;\n    }\n\n    qDebug() &lt;&lt; \"Shutting down MyPlugin...\";\n\n    // Perform cleanup logic here\n    m_state = qtplugin::PluginState::Unloaded;\n    m_initialized = false;\n\n    qDebug() &lt;&lt; \"MyPlugin shutdown complete\";\n}\n\nqtplugin::PluginState MyPlugin::state() const\n{\n    return m_state;\n}\n\nbool MyPlugin::is_initialized() const\n{\n    return m_initialized;\n}\n\nqtplugin::PluginMetadata MyPlugin::metadata() const\n{\n    return {\n        .id = \"com.example.myplugin\",\n        .name = \"My Example Plugin\",\n        .version = \"1.0.0\",\n        .description = \"An example plugin demonstrating the QtPlugin system\",\n        .author = \"Your Name\",\n        .license = \"MIT\",\n        .dependencies = {},\n        .tags = {\"example\", \"demo\"},\n        .custom_data = {}\n    };\n}\n\nstd::string MyPlugin::id() const\n{\n    return metadata().id;\n}\n\nstd::string MyPlugin::name() const\n{\n    return metadata().name;\n}\n\nstd::string MyPlugin::version() const\n{\n    return metadata().version;\n}\n\nstd::string MyPlugin::description() const\n{\n    return metadata().description;\n}\n\nqtplugin::expected&lt;void, qtplugin::PluginError&gt; MyPlugin::configure(const QJsonObject&amp; config)\n{\n    qDebug() &lt;&lt; \"Configuring MyPlugin with:\" &lt;&lt; QJsonDocument(config).toJson();\n\n    // Validate configuration\n    if (config.contains(\"invalid_key\")) {\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::ConfigurationError,\n            \"Invalid configuration key: invalid_key\"\n        });\n    }\n\n    m_configuration = config;\n    return {};\n}\n\nQJsonObject MyPlugin::current_configuration() const\n{\n    return m_configuration;\n}\n\nqtplugin::expected&lt;QJsonObject, qtplugin::PluginError&gt; MyPlugin::execute_command(\n    std::string_view command, \n    const QJsonObject&amp; params)\n{\n    if (!m_initialized) {\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::ExecutionFailed,\n            \"Plugin not initialized\"\n        });\n    }\n\n    if (command == \"hello\") {\n        QString name = params.value(\"name\").toString(\"World\");\n        QJsonObject result;\n        result[\"message\"] = QString(\"Hello, %1!\").arg(name);\n        result[\"timestamp\"] = QDateTime::currentDateTime().toString(Qt::ISODate);\n        return result;\n    }\n    else if (command == \"status\") {\n        QJsonObject result;\n        result[\"state\"] = static_cast&lt;int&gt;(m_state);\n        result[\"initialized\"] = m_initialized;\n        result[\"uptime\"] = \"unknown\"; // You could track this\n        return result;\n    }\n    else {\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::CommandNotSupported,\n            std::string(\"Unsupported command: \") + std::string(command)\n        });\n    }\n}\n\nstd::vector&lt;std::string&gt; MyPlugin::supported_commands() const\n{\n    return {\"hello\", \"status\"};\n}\n\nbool MyPlugin::supports_command(std::string_view command) const\n{\n    auto commands = supported_commands();\n    return std::find(commands.begin(), commands.end(), command) != commands.end();\n}\n\nqtplugin::PluginCapabilities MyPlugin::capabilities() const\n{\n    qtplugin::PluginCapabilities caps;\n    caps.supports_configuration = true;\n    caps.supports_hot_reload = true;\n    caps.supports_state_persistence = false;\n    caps.thread_safe = true;\n    caps.requires_ui = false;\n    caps.requires_network = false;\n    return caps;\n}\n\n#include \"my_plugin.moc\"\n</code></pre>"},{"location":"guides/plugin-development/#step-3-metadata-file","title":"Step 3: Metadata File","text":"<p>Create <code>metadata.json</code>:</p> <pre><code>{\n    \"id\": \"com.example.myplugin\",\n    \"name\": \"My Example Plugin\",\n    \"version\": \"1.0.0\",\n    \"description\": \"An example plugin demonstrating the QtPlugin system\",\n    \"author\": \"Your Name\",\n    \"license\": \"MIT\",\n    \"dependencies\": [],\n    \"tags\": [\"example\", \"demo\"],\n    \"capabilities\": {\n        \"supports_configuration\": true,\n        \"supports_hot_reload\": true,\n        \"supports_state_persistence\": false,\n        \"thread_safe\": true,\n        \"requires_ui\": false,\n        \"requires_network\": false\n    },\n    \"commands\": [\n        {\n            \"name\": \"hello\",\n            \"description\": \"Returns a greeting message\",\n            \"parameters\": {\n                \"name\": {\n                    \"type\": \"string\",\n                    \"description\": \"Name to greet\",\n                    \"default\": \"World\"\n                }\n            }\n        },\n        {\n            \"name\": \"status\",\n            \"description\": \"Returns plugin status information\",\n            \"parameters\": {}\n        }\n    ]\n}\n</code></pre>"},{"location":"guides/plugin-development/#step-4-cmake-configuration","title":"Step 4: CMake Configuration","text":"<p>Create <code>CMakeLists.txt</code>:</p> <pre><code>cmake_minimum_required(VERSION 3.20)\nproject(MyPlugin)\n\n# Find required packages\nfind_package(Qt6 REQUIRED COMPONENTS Core)\nfind_package(QtPlugin REQUIRED COMPONENTS Core)\n\n# Set C++ standard\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# Enable Qt MOC\nset(CMAKE_AUTOMOC ON)\n\n# Create plugin library\nadd_library(my_plugin SHARED\n    my_plugin.cpp\n    my_plugin.hpp\n)\n\n# Link libraries\ntarget_link_libraries(my_plugin\n    Qt6::Core\n    QtPlugin::Core\n)\n\n# Set plugin properties\nset_target_properties(my_plugin PROPERTIES\n    LIBRARY_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/plugins\"\n    RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/plugins\"\n    SUFFIX \".qtplugin\"\n)\n\n# Copy metadata file\nconfigure_file(\n    \"${CMAKE_CURRENT_SOURCE_DIR}/metadata.json\"\n    \"${CMAKE_BINARY_DIR}/plugins/metadata.json\"\n    COPYONLY\n)\n\n# Install plugin\ninstall(TARGETS my_plugin\n    LIBRARY DESTINATION plugins\n    RUNTIME DESTINATION plugins\n)\n\ninstall(FILES metadata.json\n    DESTINATION plugins\n)\n</code></pre>"},{"location":"guides/plugin-development/#advanced-topics","title":"Advanced Topics","text":""},{"location":"guides/plugin-development/#plugin-dependencies","title":"Plugin Dependencies","text":"<p>To create a plugin that depends on other plugins:</p> <pre><code>{\n    \"dependencies\": [\n        {\n            \"id\": \"com.example.base_plugin\",\n            \"version\": \"&gt;=1.0.0\",\n            \"required\": true\n        },\n        {\n            \"id\": \"com.example.optional_plugin\",\n            \"version\": \"^2.0.0\",\n            \"required\": false\n        }\n    ]\n}\n</code></pre>"},{"location":"guides/plugin-development/#inter-plugin-communication","title":"Inter-Plugin Communication","text":"<p>Use the message bus for communication:</p> <pre><code>// In your plugin\nvoid MyPlugin::sendMessage()\n{\n    auto* bus = qtplugin::MessageBus::instance();\n    QJsonObject data;\n    data[\"message\"] = \"Hello from MyPlugin\";\n    bus-&gt;publish(\"myplugin.events\", data);\n}\n\nvoid MyPlugin::subscribeToMessages()\n{\n    auto* bus = qtplugin::MessageBus::instance();\n    bus-&gt;subscribe(\"other_plugin.events\", this, SLOT(onMessageReceived(QJsonObject)));\n}\n\nvoid MyPlugin::onMessageReceived(const QJsonObject&amp; data)\n{\n    qDebug() &lt;&lt; \"Received message:\" &lt;&lt; data;\n}\n</code></pre>"},{"location":"guides/plugin-development/#configuration-management","title":"Configuration Management","text":"<p>Handle complex configuration:</p> <pre><code>qtplugin::expected&lt;void, qtplugin::PluginError&gt; MyPlugin::configure(const QJsonObject&amp; config)\n{\n    // Validate required fields\n    if (!config.contains(\"server_url\")) {\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::ConfigurationError,\n            \"Missing required field: server_url\"\n        });\n    }\n\n    // Validate types\n    if (!config[\"server_url\"].isString()) {\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::ConfigurationError,\n            \"server_url must be a string\"\n        });\n    }\n\n    // Apply configuration\n    m_serverUrl = config[\"server_url\"].toString();\n    m_timeout = config.value(\"timeout\").toInt(5000);\n    m_retries = config.value(\"retries\").toInt(3);\n\n    m_configuration = config;\n    return {};\n}\n</code></pre>"},{"location":"guides/plugin-development/#error-handling-best-practices","title":"Error Handling Best Practices","text":"<p>Always use the expected pattern: <pre><code>qtplugin::expected&lt;QJsonObject, qtplugin::PluginError&gt; MyPlugin::execute_command(\n    std::string_view command, \n    const QJsonObject&amp; params)\n{\n    try {\n        if (command == \"risky_operation\") {\n            // Perform operation that might fail\n            auto result = performRiskyOperation(params);\n            if (!result.isValid()) {\n                return qtplugin::make_unexpected(qtplugin::PluginError{\n                    qtplugin::PluginErrorCode::ExecutionFailed,\n                    \"Risky operation failed: \" + result.errorString().toStdString()\n                });\n            }\n\n            return result.toJsonObject();\n        }\n\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::CommandNotSupported,\n            std::string(\"Unknown command: \") + std::string(command)\n        });\n    }\n    catch (const std::exception&amp; e) {\n        return qtplugin::make_unexpected(qtplugin::PluginError{\n            qtplugin::PluginErrorCode::ExecutionFailed,\n            std::string(\"Exception in command execution: \") + e.what()\n        });\n    }\n}\n</code></pre>"},{"location":"guides/plugin-development/#testing-your-plugin","title":"Testing Your Plugin","text":""},{"location":"guides/plugin-development/#unit-testing","title":"Unit Testing","text":"<p>Create tests for your plugin:</p> <pre><code>#include &lt;QtTest/QtTest&gt;\n#include \"my_plugin.hpp\"\n\nclass TestMyPlugin : public QObject\n{\n    Q_OBJECT\n\nprivate slots:\n    void initTestCase();\n    void testInitialization();\n    void testCommands();\n    void testConfiguration();\n    void cleanupTestCase();\n\nprivate:\n    std::unique_ptr&lt;MyPlugin&gt; m_plugin;\n};\n\nvoid TestMyPlugin::initTestCase()\n{\n    m_plugin = std::make_unique&lt;MyPlugin&gt;();\n}\n\nvoid TestMyPlugin::testInitialization()\n{\n    auto result = m_plugin-&gt;initialize();\n    QVERIFY(result.has_value());\n    QVERIFY(m_plugin-&gt;is_initialized());\n    QCOMPARE(m_plugin-&gt;state(), qtplugin::PluginState::Running);\n}\n\nvoid TestMyPlugin::testCommands()\n{\n    QJsonObject params;\n    params[\"name\"] = \"Test\";\n\n    auto result = m_plugin-&gt;execute_command(\"hello\", params);\n    QVERIFY(result.has_value());\n    QVERIFY(result.value().contains(\"message\"));\n    QCOMPARE(result.value()[\"message\"].toString(), \"Hello, Test!\");\n}\n\nQTEST_MAIN(TestMyPlugin)\n#include \"test_my_plugin.moc\"\n</code></pre>"},{"location":"guides/plugin-development/#deployment","title":"Deployment","text":""},{"location":"guides/plugin-development/#building-for-distribution","title":"Building for Distribution","text":"<pre><code>mkdir build &amp;&amp; cd build\ncmake .. -DCMAKE_BUILD_TYPE=Release\ncmake --build . --target my_plugin\n</code></pre>"},{"location":"guides/plugin-development/#installation","title":"Installation","text":"<pre><code>cmake --install . --prefix /usr/local\n</code></pre> <p>The plugin will be installed to <code>/usr/local/plugins/</code> and can be loaded by applications using the QtPlugin system.</p>"},{"location":"guides/plugin-development/#best-practices","title":"Best Practices","text":"<ol> <li>Always implement proper error handling using expected <li>Validate all inputs in configure() and execute_command()</li> <li>Use RAII for resource management</li> <li>Make plugins thread-safe when possible</li> <li>Provide comprehensive metadata for better discoverability</li> <li>Test thoroughly with unit tests and integration tests</li> <li>Document your plugin's API clearly</li> <li>Handle shutdown gracefully to prevent resource leaks</li>"},{"location":"user-guide/troubleshooting/","title":"Troubleshooting Guide","text":"<p>This comprehensive guide helps you diagnose and resolve common issues with QtPlugin. For quick answers to common questions, see the FAQ.</p>"},{"location":"user-guide/troubleshooting/#quick-diagnostics","title":"Quick Diagnostics","text":""},{"location":"user-guide/troubleshooting/#system-check","title":"System Check","text":"<p>Run this diagnostic code to check your QtPlugin installation:</p> <pre><code>#include &lt;qtplugin/qtplugin.hpp&gt;\n#include &lt;iostream&gt;\n\nvoid run_diagnostics() {\n    std::cout &lt;&lt; \"=== QtPlugin Diagnostics ===\" &lt;&lt; std::endl;\n\n    // 1. Check library initialization\n    std::cout &lt;&lt; \"1. Library initialization...\" &lt;&lt; std::endl;\n    qtplugin::LibraryInitializer init;\n    if (!init.is_initialized()) {\n        std::cout &lt;&lt; \"\u274c FAILED: Library initialization failed\" &lt;&lt; std::endl;\n        return;\n    }\n    std::cout &lt;&lt; \"\u2705 SUCCESS: Library initialized\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"   Version: \" &lt;&lt; qtplugin::version_string() &lt;&lt; std::endl;\n\n    // 2. Check Qt version\n    std::cout &lt;&lt; \"\\n2. Qt version check...\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"   Qt version: \" &lt;&lt; QT_VERSION_STR &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"   Runtime Qt: \" &lt;&lt; qVersion() &lt;&lt; std::endl;\n\n    // 3. Check plugin manager\n    std::cout &lt;&lt; \"\\n3. Plugin manager creation...\" &lt;&lt; std::endl;\n    auto manager = qtplugin::PluginManager::create();\n    if (!manager) {\n        std::cout &lt;&lt; \"\u274c FAILED: Plugin manager creation failed\" &lt;&lt; std::endl;\n        return;\n    }\n    std::cout &lt;&lt; \"\u2705 SUCCESS: Plugin manager created\" &lt;&lt; std::endl;\n\n    // 4. Check security manager\n    std::cout &lt;&lt; \"\\n4. Security manager check...\" &lt;&lt; std::endl;\n    auto&amp; security = manager-&gt;security_manager();\n    std::cout &lt;&lt; \"\u2705 SUCCESS: Security manager available\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"   Security level: \" &lt;&lt; static_cast&lt;int&gt;(security.current_level()) &lt;&lt; std::endl;\n\n    // 5. Check message bus\n    std::cout &lt;&lt; \"\\n5. Message bus check...\" &lt;&lt; std::endl;\n    auto&amp; bus = manager-&gt;message_bus();\n    std::cout &lt;&lt; \"\u2705 SUCCESS: Message bus available\" &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"\\n=== Diagnostics Complete ===\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"user-guide/troubleshooting/#environment-check","title":"Environment Check","text":"<p>Verify your development environment:</p> <pre><code># Check Qt installation\nqmake --version  # or qmake6 --version\n\n# Check CMake version\ncmake --version\n\n# Check compiler version\ng++ --version    # Linux\nclang++ --version  # macOS\n# Check Visual Studio version in IDE (Windows)\n\n# Check QtPlugin installation\npkg-config --exists qtplugin &amp;&amp; echo \"QtPlugin found\" || echo \"QtPlugin not found\"\npkg-config --modversion qtplugin\n</code></pre>"},{"location":"user-guide/troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"user-guide/troubleshooting/#qt-not-found","title":"Qt Not Found","text":"<p>Problem: CMake cannot find Qt6</p> <p>Symptoms: <pre><code>CMake Error: Could not find a package configuration file provided by \"Qt6\"\n</code></pre></p> <p>Solutions:</p> Set Qt6_DIREnvironment VariablesQt Online Installer <pre><code># Find Qt installation\nfind /usr -name \"Qt6Config.cmake\" 2&gt;/dev/null\n# Windows: dir /s Qt6Config.cmake\n\n# Set Qt6_DIR in CMake\ncmake .. -DQt6_DIR=/path/to/qt6/lib/cmake/Qt6\n</code></pre> <pre><code># Linux/macOS\nexport CMAKE_PREFIX_PATH=\"/path/to/qt6:$CMAKE_PREFIX_PATH\"\nexport PATH=\"/path/to/qt6/bin:$PATH\"\n\n# Windows\nset CMAKE_PREFIX_PATH=C:\\Qt\\6.5.0\\msvc2019_64;%CMAKE_PREFIX_PATH%\nset PATH=C:\\Qt\\6.5.0\\msvc2019_64\\bin;%PATH%\n</code></pre> <pre><code># Install Qt using the official installer\n# Download from: https://www.qt.io/download-qt-installer\n\n# Or use package managers:\n# Ubuntu: sudo apt install qt6-base-dev\n# macOS: brew install qt6\n# Windows: winget install Qt.Qt\n</code></pre>"},{"location":"user-guide/troubleshooting/#compiler-issues","title":"Compiler Issues","text":"<p>Problem: C++20 features not available</p> <p>Symptoms: <pre><code>error: 'expected' is not a member of 'std'\nerror: 'concept' does not name a type\n</code></pre></p> <p>Solutions:</p> <ol> <li>Update Compiler:</li> <li>GCC: Use version 10 or later</li> <li>Clang: Use version 12 or later</li> <li> <p>MSVC: Use Visual Studio 2019 16.8 or later</p> </li> <li> <p>Check Compiler Flags:    <pre><code># Ensure C++20 is enabled\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# Compiler-specific flags\nif(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n    add_compile_options(-fcoroutines)\nelseif(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n    add_compile_options(-fcoroutines-ts)\nelseif(MSVC)\n    add_compile_options(/await)\nendif()\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#cmake-version-issues","title":"CMake Version Issues","text":"<p>Problem: CMake version too old</p> <p>Symptoms: <pre><code>CMake Error: CMake 3.21 or higher is required. You are running version 3.16.3\n</code></pre></p> <p>Solutions:</p> Linux (Ubuntu/Debian)macOSWindows <pre><code># Remove old version\nsudo apt remove cmake\n\n# Add Kitware repository\nwget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc | gpg --dearmor - | sudo tee /etc/apt/trusted.gpg.d/kitware.gpg\nsudo apt-add-repository 'deb https://apt.kitware.com/ubuntu/ focal main'\nsudo apt update &amp;&amp; sudo apt install cmake\n</code></pre> <pre><code># Using Homebrew\nbrew install cmake\n\n# Or download from cmake.org\n</code></pre> <pre><code># Using winget\nwinget install Kitware.CMake\n\n# Or download installer from cmake.org\n</code></pre>"},{"location":"user-guide/troubleshooting/#build-issues","title":"Build Issues","text":""},{"location":"user-guide/troubleshooting/#missing-dependencies","title":"Missing Dependencies","text":"<p>Problem: Build fails due to missing libraries</p> <p>Symptoms: <pre><code>fatal error: 'QCore' file not found\nundefined reference to 'Qt6::Core'\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Install Qt Development Packages:    <pre><code># Ubuntu/Debian\nsudo apt install qt6-base-dev qt6-tools-dev\n\n# CentOS/RHEL/Fedora\nsudo dnf install qt6-qtbase-devel qt6-qttools-devel\n\n# Arch Linux\nsudo pacman -S qt6-base qt6-tools\n</code></pre></p> </li> <li> <p>Check CMake Configuration:    <pre><code># Verify required components\nfind_package(Qt6 REQUIRED COMPONENTS Core)\nfind_package(QtPlugin REQUIRED COMPONENTS Core Security)\n\n# Link libraries\ntarget_link_libraries(your_target\n    Qt6::Core\n    QtPlugin::Core\n    QtPlugin::Security\n)\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#linker-errors","title":"Linker Errors","text":"<p>Problem: Undefined symbols during linking</p> <p>Symptoms: <pre><code>undefined reference to `qtplugin::PluginManager::create()'\nundefined symbol: _ZN8qtplugin13PluginManager6createEv\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Check Library Linking:    <pre><code># Ensure proper linking order\ntarget_link_libraries(your_target\n    QtPlugin::Core      # Link QtPlugin first\n    QtPlugin::Security  # Then additional components\n    Qt6::Core          # Then Qt\n)\n</code></pre></p> </li> <li> <p>Verify Installation:    <pre><code># Check if libraries are installed\nfind /usr/local -name \"libqtplugin*\" 2&gt;/dev/null\n\n# Check library symbols\nnm -D /usr/local/lib/libqtplugin-core.a | grep PluginManager\n</code></pre></p> </li> <li> <p>Static vs Dynamic Linking:    <pre><code># For static linking (default)\nset(BUILD_SHARED_LIBS OFF)\n\n# For dynamic linking\nset(BUILD_SHARED_LIBS ON)\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#runtime-issues","title":"Runtime Issues","text":""},{"location":"user-guide/troubleshooting/#plugin-loading-failures","title":"Plugin Loading Failures","text":"<p>Problem: Plugins fail to load at runtime</p> <p>Symptoms: <pre><code>Failed to load plugin: Library loading failed\nPlugin validation failed\nSymbol not found: plugin_create_instance\n</code></pre></p> <p>Debugging Steps:</p> <ol> <li> <p>Enable Debug Logging:    <pre><code>// Enable detailed logging\nqtplugin::set_log_level(qtplugin::LogLevel::Debug);\nqtplugin::enable_component_logging(true);\n\n// Load plugin with detailed error reporting\nauto result = manager-&gt;load_plugin(\"plugin.so\");\nif (!result) {\n    auto error = result.error();\n    qDebug() &lt;&lt; \"Error code:\" &lt;&lt; static_cast&lt;int&gt;(error.code);\n    qDebug() &lt;&lt; \"Message:\" &lt;&lt; error.message.c_str();\n    qDebug() &lt;&lt; \"Details:\" &lt;&lt; error.details.c_str();\n    qDebug() &lt;&lt; \"File:\" &lt;&lt; error.file.c_str();\n    qDebug() &lt;&lt; \"Line:\" &lt;&lt; error.line;\n}\n</code></pre></p> </li> <li> <p>Check Plugin File:    <pre><code># Verify file exists and is readable\nls -la plugin.so\n\n# Check file type\nfile plugin.so\n\n# Check dependencies (Linux)\nldd plugin.so\n\n# Check dependencies (macOS)\notool -L plugin.so\n\n# Check exported symbols\nnm -D plugin.so | grep qtplugin\n</code></pre></p> </li> <li> <p>Verify Plugin Interface:    <pre><code>// Check if plugin exports required symbols\nQPluginLoader loader(\"plugin.so\");\nif (!loader.load()) {\n    qDebug() &lt;&lt; \"Qt plugin loading failed:\" &lt;&lt; loader.errorString();\n}\n\n// Check interface\nauto instance = loader.instance();\nauto plugin = qobject_cast&lt;qtplugin::IPlugin*&gt;(instance);\nif (!plugin) {\n    qDebug() &lt;&lt; \"Plugin doesn't implement IPlugin interface\";\n}\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#abi-compatibility-issues","title":"ABI Compatibility Issues","text":"<p>Problem: Plugin loads but crashes or behaves incorrectly</p> <p>Symptoms: <pre><code>Segmentation fault\nPure virtual function called\nUnexpected behavior\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Check Compiler Compatibility:    <pre><code># Ensure same compiler for app and plugin\n# Check compiler version used for each\nstrings your_app | grep GCC\nstrings plugin.so | grep GCC\n</code></pre></p> </li> <li> <p>Verify Qt Versions:    <pre><code>// Check Qt version compatibility\nqDebug() &lt;&lt; \"App Qt version:\" &lt;&lt; QT_VERSION_STR;\nqDebug() &lt;&lt; \"Runtime Qt version:\" &lt;&lt; qVersion();\n\n// In plugin, check Qt version\nqDebug() &lt;&lt; \"Plugin compiled with Qt:\" &lt;&lt; QT_VERSION_STR;\n</code></pre></p> </li> <li> <p>Check C++ Standard Library:    <pre><code># Ensure same standard library\nldd your_app | grep libstdc++\nldd plugin.so | grep libstdc++\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#memory-issues","title":"Memory Issues","text":"<p>Problem: Memory leaks or crashes related to memory</p> <p>Symptoms: <pre><code>Heap corruption detected\nDouble free or corruption\nMemory leak detected\n</code></pre></p> <p>Debugging Tools:</p> <ol> <li> <p>Valgrind (Linux):    <pre><code># Check for memory leaks\nvalgrind --leak-check=full --show-leak-kinds=all ./your_app\n\n# Check for memory errors\nvalgrind --tool=memcheck ./your_app\n</code></pre></p> </li> <li> <p>AddressSanitizer:    <pre><code># Enable AddressSanitizer\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fsanitize=address -g\")\nset(CMAKE_LINKER_FLAGS \"${CMAKE_LINKER_FLAGS} -fsanitize=address\")\n</code></pre></p> </li> <li> <p>Qt Creator Debugger:</p> </li> <li>Use built-in memory analyzer</li> <li>Set breakpoints in destructors</li> <li>Monitor object lifetimes</li> </ol>"},{"location":"user-guide/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"user-guide/troubleshooting/#slow-plugin-loading","title":"Slow Plugin Loading","text":"<p>Problem: Plugins take too long to load</p> <p>Symptoms: - Application freezes during plugin loading - Long startup times - Timeout errors</p> <p>Solutions:</p> <ol> <li> <p>Profile Plugin Loading:    <pre><code>#include &lt;QElapsedTimer&gt;\n\nQElapsedTimer timer;\ntimer.start();\n\nauto result = manager-&gt;load_plugin(\"plugin.so\");\n\nqDebug() &lt;&lt; \"Plugin loading took:\" &lt;&lt; timer.elapsed() &lt;&lt; \"ms\";\n</code></pre></p> </li> <li> <p>Use Parallel Loading:    <pre><code>#include &lt;future&gt;\n#include &lt;vector&gt;\n\nstd::vector&lt;std::future&lt;expected&lt;std::string, PluginError&gt;&gt;&gt; futures;\n\nfor (const auto&amp; path : plugin_paths) {\n    futures.push_back(std::async(std::launch::async, [&amp;]() {\n        return manager-&gt;load_plugin(path);\n    }));\n}\n\n// Wait for all plugins to load\nfor (auto&amp; future : futures) {\n    auto result = future.get();\n    // Handle result...\n}\n</code></pre></p> </li> <li> <p>Optimize Plugin Initialization:    <pre><code>// Load plugin without immediate initialization\nauto result = manager-&gt;load_plugin(path, LoadOptions{.initialize = false});\n\n// Initialize later when needed\nauto plugin = manager-&gt;get_plugin(result.value());\nplugin-&gt;initialize();\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Problem: Application uses too much memory with plugins</p> <p>Solutions:</p> <ol> <li> <p>Monitor Memory Usage:    <pre><code>// Get memory statistics\nauto stats = manager-&gt;memory_statistics();\nqDebug() &lt;&lt; \"Total plugin memory:\" &lt;&lt; stats.total_memory_usage;\nqDebug() &lt;&lt; \"Plugin count:\" &lt;&lt; stats.loaded_plugin_count;\nqDebug() &lt;&lt; \"Average per plugin:\" &lt;&lt; stats.average_memory_per_plugin;\n</code></pre></p> </li> <li> <p>Implement Plugin Unloading:    <pre><code>// Unload unused plugins\nauto unused_plugins = manager-&gt;find_unused_plugins(std::chrono::minutes(10));\nfor (const auto&amp; plugin_id : unused_plugins) {\n    manager-&gt;unload_plugin(plugin_id);\n}\n</code></pre></p> </li> <li> <p>Use Memory Limits:    <pre><code>// Set memory limits for plugins\nPluginLoadOptions options;\noptions.max_memory_usage = 50 * 1024 * 1024; // 50MB\noptions.enable_memory_monitoring = true;\n\nauto result = manager-&gt;load_plugin(\"plugin.so\", options);\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#security-issues","title":"Security Issues","text":""},{"location":"user-guide/troubleshooting/#plugin-validation-failures","title":"Plugin Validation Failures","text":"<p>Problem: Plugins fail security validation</p> <p>Symptoms: <pre><code>Plugin validation failed: Untrusted publisher\nSecurity check failed: Invalid signature\nPlugin blocked by security policy\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Check Security Configuration:    <pre><code>auto&amp; security = manager-&gt;security_manager();\nauto config = security.current_configuration();\n\nqDebug() &lt;&lt; \"Security level:\" &lt;&lt; static_cast&lt;int&gt;(config.level);\nqDebug() &lt;&lt; \"Signature validation:\" &lt;&lt; config.require_signatures;\nqDebug() &lt;&lt; \"Trust validation:\" &lt;&lt; config.require_trusted_publishers;\n</code></pre></p> </li> <li> <p>Adjust Security Settings:    <pre><code>SecurityConfiguration config;\nconfig.level = SecurityLevel::Medium;  // Reduce from High\nconfig.require_signatures = false;     // Disable signature requirement\nconfig.allow_unsigned_plugins = true;  // Allow unsigned plugins\n\nsecurity.configure(config);\n</code></pre></p> </li> <li> <p>Add Trusted Publishers:    <pre><code>// Add publisher to trust list\nsecurity.add_trusted_publisher(\"com.example.publisher\");\n\n// Or trust specific plugin\nsecurity.add_trusted_plugin(\"com.example.specific-plugin\");\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#permission-denied-errors","title":"Permission Denied Errors","text":"<p>Problem: Plugins can't access required resources</p> <p>Solutions:</p> <ol> <li> <p>Check File Permissions:    <pre><code># Verify plugin file permissions\nls -la plugin.so\n\n# Check directory permissions\nls -ld /path/to/plugins/\n\n# Fix permissions if needed\nchmod 755 plugin.so\nchmod 755 /path/to/plugins/\n</code></pre></p> </li> <li> <p>Configure Plugin Permissions:    <pre><code>PluginPermissions permissions;\npermissions.allow_file_system_access = true;\npermissions.allow_network_access = true;\npermissions.allowed_directories = {\"/tmp\", \"/var/data\"};\n\nmanager-&gt;set_plugin_permissions(\"plugin.id\", permissions);\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#communication-issues","title":"Communication Issues","text":""},{"location":"user-guide/troubleshooting/#message-bus-problems","title":"Message Bus Problems","text":"<p>Problem: Inter-plugin communication not working</p> <p>Symptoms: - Messages not delivered - Subscribers not receiving messages - Request-response timeouts</p> <p>Debugging:</p> <ol> <li> <p>Enable Message Bus Logging:    <pre><code>auto&amp; bus = manager-&gt;message_bus();\nbus.enable_debug_logging(true);\n\n// Check message statistics\nauto stats = bus.statistics();\nqDebug() &lt;&lt; \"Messages sent:\" &lt;&lt; stats.messages_sent;\nqDebug() &lt;&lt; \"Messages delivered:\" &lt;&lt; stats.messages_delivered;\nqDebug() &lt;&lt; \"Active subscriptions:\" &lt;&lt; stats.active_subscriptions;\n</code></pre></p> </li> <li> <p>Verify Message Types:    <pre><code>// Ensure message types are properly registered\nbus.register_message_type&lt;MyMessageType&gt;();\n\n// Check if type is registered\nif (!bus.is_message_type_registered&lt;MyMessageType&gt;()) {\n    qDebug() &lt;&lt; \"Message type not registered!\";\n}\n</code></pre></p> </li> <li> <p>Test Message Delivery:    <pre><code>// Simple test message\nstruct TestMessage {\n    QString content;\n};\n\n// Subscribe\nbus.subscribe&lt;TestMessage&gt;([](const TestMessage&amp; msg) {\n    qDebug() &lt;&lt; \"Received test message:\" &lt;&lt; msg.content;\n});\n\n// Publish\nbus.publish(TestMessage{\"Hello, World!\"});\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#development-issues","title":"Development Issues","text":""},{"location":"user-guide/troubleshooting/#plugin-development-problems","title":"Plugin Development Problems","text":"<p>Problem: Issues during plugin development</p> <p>Common Issues and Solutions:</p> <ol> <li> <p>Plugin Not Recognized:    <pre><code>// Ensure proper Qt plugin macros\nQ_OBJECT\nQ_PLUGIN_METADATA(IID \"qtplugin.IPlugin/3.0\" FILE \"metadata.json\")\nQ_INTERFACES(qtplugin::IPlugin)\n\n// Include moc file\n#include \"myplugin.moc\"\n</code></pre></p> </li> <li> <p>Metadata File Issues:    <pre><code>{\n    \"id\": \"com.example.myplugin\",\n    \"name\": \"My Plugin\",\n    \"version\": \"1.0.0\",\n    \"description\": \"Plugin description\",\n    \"author\": \"Author Name\",\n    \"qtplugin_version\": \"3.0.0\"\n}\n</code></pre></p> </li> <li> <p>CMake Configuration:    <pre><code># Use QtPlugin helper function\nqtplugin_add_plugin(my_plugin\n    TYPE service\n    SOURCES my_plugin.cpp\n    HEADERS my_plugin.hpp\n    METADATA metadata.json\n    DEPENDENCIES Qt6::Network\n)\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#testing-issues","title":"Testing Issues","text":"<p>Problem: Difficulty testing plugins</p> <p>Solutions:</p> <ol> <li> <p>Unit Testing Framework:    <pre><code>#include &lt;QtTest&gt;\n#include &lt;qtplugin/testing/plugin_test_framework.hpp&gt;\n\nclass PluginTest : public QObject {\n    Q_OBJECT\n\nprivate slots:\n    void testPluginLoading();\n    void testPluginCommands();\n};\n\nvoid PluginTest::testPluginLoading() {\n    qtplugin::testing::PluginTestFramework framework;\n\n    auto result = framework.load_test_plugin(\"my_plugin.so\");\n    QVERIFY(result.has_value());\n\n    auto plugin = framework.get_plugin(result.value());\n    QVERIFY(plugin != nullptr);\n    QVERIFY(plugin-&gt;is_initialized());\n}\n</code></pre></p> </li> <li> <p>Mock Plugin Manager:    <pre><code>#include &lt;qtplugin/testing/mock_plugin_manager.hpp&gt;\n\nqtplugin::testing::MockPluginManager mock_manager;\nmock_manager.expect_load_plugin(\"test_plugin.so\")\n            .will_return(\"test.plugin.id\");\n\n// Test your code with mock manager\n</code></pre></p> </li> </ol>"},{"location":"user-guide/troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"user-guide/troubleshooting/#diagnostic-information","title":"Diagnostic Information","text":"<p>When seeking help, provide this diagnostic information:</p> <pre><code>void collect_diagnostic_info() {\n    qDebug() &lt;&lt; \"=== System Information ===\";\n    qDebug() &lt;&lt; \"OS:\" &lt;&lt; QSysInfo::prettyProductName();\n    qDebug() &lt;&lt; \"Architecture:\" &lt;&lt; QSysInfo::currentCpuArchitecture();\n    qDebug() &lt;&lt; \"Qt version:\" &lt;&lt; qVersion();\n    qDebug() &lt;&lt; \"QtPlugin version:\" &lt;&lt; qtplugin::version_string();\n\n    qDebug() &lt;&lt; \"\\n=== Build Information ===\";\n    qDebug() &lt;&lt; \"Compiler:\" &lt;&lt;\n    #ifdef __GNUC__\n        \"GCC\" &lt;&lt; __GNUC__ &lt;&lt; \".\" &lt;&lt; __GNUC_MINOR__;\n    #elif defined(__clang__)\n        \"Clang\" &lt;&lt; __clang_major__ &lt;&lt; \".\" &lt;&lt; __clang_minor__;\n    #elif defined(_MSC_VER)\n        \"MSVC\" &lt;&lt; _MSC_VER;\n    #else\n        \"Unknown\";\n    #endif\n\n    qDebug() &lt;&lt; \"C++ standard:\" &lt;&lt; __cplusplus;\n\n    qDebug() &lt;&lt; \"\\n=== Plugin Manager State ===\";\n    if (auto manager = qtplugin::PluginManager::instance()) {\n        auto stats = manager-&gt;statistics();\n        qDebug() &lt;&lt; \"Loaded plugins:\" &lt;&lt; stats.loaded_plugin_count;\n        qDebug() &lt;&lt; \"Failed loads:\" &lt;&lt; stats.failed_load_count;\n        qDebug() &lt;&lt; \"Memory usage:\" &lt;&lt; stats.total_memory_usage;\n    }\n}\n</code></pre>"},{"location":"user-guide/troubleshooting/#support-channels","title":"Support Channels","text":"<ul> <li>\ud83d\udcd6 Documentation: Browse this comprehensive guide</li> <li>\ud83d\udca1 Examples: Check examples for working code</li> <li>\ud83d\udc1b Bug Reports: GitHub Issues</li> <li>\ud83d\udcac Questions: GitHub Discussions</li> <li>\ud83d\udce7 Enterprise: Contact maintainers for commercial support</li> </ul>"},{"location":"user-guide/troubleshooting/#creating-bug-reports","title":"Creating Bug Reports","text":"<p>Include this information in bug reports:</p> <ol> <li>System Information (use diagnostic code above)</li> <li>Reproduction Steps (minimal example)</li> <li>Expected vs Actual Behavior</li> <li>Error Messages (complete output)</li> <li>Code Samples (minimal reproducible case)</li> </ol>"},{"location":"user-guide/troubleshooting/#performance-profiling","title":"Performance Profiling","text":"<p>For performance issues, use profiling tools:</p> <pre><code># Linux - perf\nperf record -g ./your_app\nperf report\n\n# macOS - Instruments\ninstruments -t \"Time Profiler\" ./your_app\n\n# Windows - Visual Studio Profiler\n# Use built-in profiler in Visual Studio\n</code></pre> <p>Remember: Most issues have simple solutions. Check the FAQ first, then use the debugging techniques in this guide to narrow down the problem.</p>"}]}