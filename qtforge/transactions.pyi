"""
QtForge Transactions Module Type Stubs

This module provides transaction management for atomic plugin operations.
"""

from typing import Dict, List, Any, Optional
from enum import Enum

class TransactionState(Enum):
    """Transaction state enumeration."""
    Active = ...
    Preparing = ...
    Prepared = ...
    Committing = ...
    Committed = ...
    Aborting = ...
    Aborted = ...
    Failed = ...
    Timeout = ...

class IsolationLevel(Enum):
    """Transaction isolation level enumeration."""
    ReadUncommitted = ...
    ReadCommitted = ...
    RepeatableRead = ...
    Serializable = ...

class TransactionOperation:
    """Represents a single operation within a transaction."""
    operation_type: str
    target_id: str
    data: Dict[str, Any]
    
    def __init__(self) -> None: ...

class ITransactionParticipant:
    """Interface for transaction participants."""
    def prepare(self, transaction_id: str) -> bool: ...
    def commit(self, transaction_id: str) -> bool: ...
    def rollback(self, transaction_id: str) -> bool: ...

class PluginTransactionManager:
    """Plugin transaction manager (singleton)."""
    @staticmethod
    def instance() -> 'PluginTransactionManager': ...
    
    def begin_transaction(self, isolation: IsolationLevel = IsolationLevel.ReadCommitted) -> Optional[str]: ...
    def commit_transaction(self, transaction_id: str) -> Optional[bool]: ...
    def rollback_transaction(self, transaction_id: str) -> Optional[bool]: ...
    def add_operation(self, transaction_id: str, operation: TransactionOperation) -> Optional[bool]: ...
    def register_participant(self, participant: ITransactionParticipant) -> bool: ...
    def unregister_participant(self, participant: ITransactionParticipant) -> bool: ...
    def get_transaction(self, transaction_id: str) -> Optional[Dict[str, Any]]: ...
    def has_transaction(self, transaction_id: str) -> bool: ...
    def get_active_transactions(self) -> List[str]: ...
    def set_default_timeout(self, timeout_ms: int) -> None: ...
    def get_default_timeout(self) -> int: ...
    def clear_completed_transactions(self) -> None: ...

# Utility functions
def get_transaction_manager() -> PluginTransactionManager: ...
def execute_atomic_operation(operations: List[TransactionOperation], 
                           isolation: IsolationLevel = IsolationLevel.ReadCommitted) -> bool: ...
