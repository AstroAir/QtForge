"""
QtForge Python Bindings Type Stubs

Type definitions for the QtForge C++ extension module.
This file provides type information for mypy static type checking.
"""

from typing import Any, Tuple, Optional, Union, List, Dict, Callable
from typing_extensions import Self
from datetime import datetime
import json

# Module-level attributes
__version__: str
__version_major__: int
__version_minor__: int
__version_patch__: int

# Core classes
class PluginManager:
    """Plugin manager for loading and managing plugins."""
    def __init__(self) -> None: ...
    def plugin_count(self) -> int: ...

class Version:
    """Version class for handling semantic versioning."""
    def __init__(self, *args: Union[int, str]) -> None: ...  # Supports both (major, minor, patch) and (version_string)
    def __str__(self) -> str: ...
    def __lt__(self, other: Version) -> bool: ...
    def __le__(self, other: Version) -> bool: ...
    def __gt__(self, other: Version) -> bool: ...
    def __ge__(self, other: Version) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class PluginMetadata:
    """Plugin metadata class."""
    def __init__(self) -> None: ...
    name: str
    version: Union[str, Version]
    description: str
    author: str

class PluginError(Exception):
    """Plugin error exception."""
    def __init__(self, code: int, message: str) -> None: ...

class PluginErrorCode:
    """Plugin error codes."""
    LOAD_FAILED: int
    INVALID_FORMAT: int
    DEPENDENCY_MISSING: int
    InvalidArgument: int

# Module-level functions
def version() -> str:
    """Get QtForge version string."""
    ...

def version_info() -> Tuple[int, int, int]:
    """Get QtForge version as tuple (major, minor, patch)."""
    ...

def test_function() -> str:
    """Test function for verifying bindings work."""
    ...

def get_version() -> str:
    """Get version string (alias for version())."""
    ...

def create_plugin_manager() -> PluginManager:
    """Create a new PluginManager instance."""
    ...

def load_plugin_demo(plugin_path: str) -> str:
    """Demo function for plugin loading."""
    ...

def utils_test() -> str:
    """Test function for utils module."""
    ...

def create_version(major: int, minor: int, patch: int) -> str:
    """Create a version string from major, minor, patch numbers."""
    ...

def parse_version(version_string: str) -> str:
    """Parse a version string and return formatted result."""
    ...

def create_error(code: int, message: str) -> str:
    """Create an error message with code and description."""
    ...

# Submodules
class CoreModule:
    """Core module containing plugin system functions."""
    def test_function(self) -> str: ...
    def get_version(self) -> str: ...
    def create_plugin_manager(self) -> PluginManager: ...
    def load_plugin_demo(self, plugin_path: str) -> str: ...

class UtilsModule:
    """Utils module containing utility functions."""
    def utils_test(self) -> str: ...
    def create_version(self, major: int, minor: int, patch: int) -> str: ...
    def parse_version(self, version_string: str) -> str: ...
    def create_error(self, code: int, message: str) -> str: ...
    def register_qt_conversions(self) -> None: ...

class MessageBus:
    """Message bus for inter-plugin communication."""
    def __init__(self) -> None: ...

class SecurityManager:
    """Security manager for plugin security."""
    def __init__(self) -> None: ...
    def get_security_level(self) -> str: ...

class ConfigurationManager:
    """Configuration manager for plugin settings."""
    def __init__(self) -> None: ...

class CommunicationModule:
    """Communication module for message bus functionality."""
    MessageBus: type[MessageBus]

class SecurityModule:
    """Security module for plugin security management."""
    SecurityManager: type[SecurityManager]

class ManagersModule:
    """Managers module for various manager classes."""
    ConfigurationManager: type[ConfigurationManager]

# Enhanced core classes with comprehensive bindings
class PluginState:
    Unloaded: int
    Loaded: int
    Initialized: int
    Running: int
    Stopped: int
    Error: int

class PluginCapability:
    None_: int
    Service: int
    UI: int
    Network: int
    DataProcessor: int
    Scripting: int

class PluginPriority:
    Lowest: int
    Low: int
    Normal: int
    High: int
    Highest: int

class IPlugin:
    def name(self) -> str: ...
    def description(self) -> str: ...
    def version(self) -> str: ...
    def author(self) -> str: ...
    def id(self) -> str: ...
    def initialize(self) -> bool: ...
    def shutdown(self) -> bool: ...
    def state(self) -> int: ...
    def capabilities(self) -> int: ...
    def execute_command(self, command: str, params: Dict[str, Any]) -> Any: ...
    def available_commands(self) -> List[str]: ...

class PluginLoader:
    def __init__(self) -> None: ...
    def load_plugin(self, path: str) -> Optional[IPlugin]: ...
    def unload_plugin(self, plugin_id: str) -> bool: ...
    def is_plugin_loaded(self, plugin_id: str) -> bool: ...
    def get_loaded_plugins(self) -> List[str]: ...

class PluginRegistry:
    def __init__(self) -> None: ...
    def register_plugin(self, plugin: IPlugin) -> bool: ...
    def unregister_plugin(self, plugin_id: str) -> bool: ...
    def get_plugin(self, plugin_id: str) -> Optional[IPlugin]: ...
    def has_plugin(self, plugin_id: str) -> bool: ...
    def get_all_plugins(self) -> List[IPlugin]: ...
    def get_plugins_by_capability(self, capability: int) -> List[IPlugin]: ...
    def clear(self) -> None: ...
    def size(self) -> int: ...

# Orchestration classes
class StepStatus:
    Pending: int
    Running: int
    Completed: int
    Failed: int
    Skipped: int
    Cancelled: int
    Retrying: int

class ExecutionMode:
    Sequential: int
    Parallel: int
    Conditional: int
    Pipeline: int

class WorkflowStep:
    def __init__(self) -> None: ...
    id: str
    name: str
    description: str
    plugin_id: str
    service_name: str
    method_name: str
    parameters: Dict[str, Any]
    dependencies: List[str]
    max_retries: int
    critical: bool
    metadata: Dict[str, Any]

class StepResult:
    def __init__(self) -> None: ...
    step_id: str
    status: int
    result_data: Dict[str, Any]
    error_message: str
    retry_count: int
    def execution_time(self) -> int: ...

class Workflow:
    def __init__(self, id: str, name: str = "") -> None: ...
    def set_description(self, desc: str) -> 'Workflow': ...
    def set_execution_mode(self, mode: int) -> 'Workflow': ...
    def add_step(self, step: WorkflowStep) -> 'Workflow': ...
    def add_rollback_step(self, step: WorkflowStep) -> 'Workflow': ...
    def id(self) -> str: ...
    def name(self) -> str: ...
    def description(self) -> str: ...
    def execution_mode(self) -> int: ...

class PluginOrchestrator:
    def __init__(self) -> None: ...
    @staticmethod
    def create() -> 'PluginOrchestrator': ...
    def register_workflow(self, workflow: Workflow) -> bool: ...
    def unregister_workflow(self, workflow_id: str) -> bool: ...
    def has_workflow(self, workflow_id: str) -> bool: ...
    def get_workflow(self, workflow_id: str) -> Optional[Workflow]: ...
    def list_workflows(self) -> List[str]: ...
    def execute_workflow(self, workflow_id: str, params: Dict[str, Any] = {}) -> bool: ...
    def cancel_workflow(self, workflow_id: str) -> bool: ...
    def get_workflow_status(self, workflow_id: str) -> Dict[str, Any]: ...
    def get_workflow_results(self, workflow_id: str) -> List[StepResult]: ...
    def clear_workflows(self) -> None: ...

# Convenience functions for all new modules
def create_plugin_loader() -> PluginLoader: ...
def create_plugin_registry() -> PluginRegistry: ...
def create_message_bus() -> MessageBus: ...
def create_configuration_manager() -> ConfigurationManager: ...
def create_logging_manager() -> Any: ...
def create_resource_manager() -> Any: ...
def create_orchestrator() -> PluginOrchestrator: ...
def create_workflow(id: str, name: str = "") -> Workflow: ...
def create_workflow_step(id: str, plugin_id: str, method: str) -> WorkflowStep: ...
def create_hot_reload_manager() -> Any: ...
def create_metrics_collector() -> Any: ...
def setup_monitoring_system(metrics_interval: int = 5000) -> Tuple[Any, Any]: ...
def create_transaction_manager() -> Any: ...
def create_transaction_operation(op_id: str, plugin_id: str, type: int) -> Any: ...
def create_transaction_context(tx_id: str, isolation: int = 0) -> Any: ...
def execute_atomic_operation(manager: Any, operations: List[Any], isolation: int = 0) -> bool: ...
def create_composition_manager() -> Any: ...
def create_composition(id: str, name: str = "") -> Any: ...
def create_composition_binding(src_plugin: str, src_method: str, tgt_plugin: str, tgt_method: str) -> Any: ...
def create_pipeline_composition(id: str, plugin_ids: List[str]) -> Any: ...
def create_facade_composition(id: str, facade_plugin: str, backend_plugins: List[str]) -> Any: ...
def create_marketplace(url: str = "https://plugins.qtforge.org") -> Any: ...
def create_search_filters(query: str = "") -> Any: ...
def search_free_plugins(marketplace: Any, query: str) -> Any: ...
def get_top_rated_plugins(marketplace: Any, limit: int = 20) -> Any: ...
def create_thread_pool(max_threads: int = 4) -> Any: ...
def create_thread_pool_manager() -> Any: ...

# Module definitions
core: CoreModule
utils: UtilsModule
communication: CommunicationModule
security: SecurityModule
managers: ManagersModule
orchestration: Any
monitoring: Any
transactions: Any
composition: Any
marketplace: Any
threading: Any
