"""
QtForge Python Bindings Type Stubs

Type definitions for the QtForge C++ extension module.
This file provides type information for mypy static type checking.
"""

from typing import Any, Tuple, Optional, Union, List, Dict, Callable
from typing_extensions import Self
from datetime import datetime
import json
from pathlib import Path

# Module-level attributes
__version__: str
__version_major__: int
__version_minor__: int
__version_patch__: int

class PluginErrorCode:
    """Plugin error codes."""
    LOAD_FAILED: int
    INVALID_FORMAT: int
    DEPENDENCY_MISSING: int
    InvalidArgument: int

# Module-level functions
def get_version() -> str:
    """Get QtForge version string."""
    ...

def get_version_info() -> Tuple[int, int, int]:
    """Get QtForge version as tuple (major, minor, patch)."""
    ...

def test_function() -> str:
    """Test function for verifying bindings work."""
    ...

def get_build_info() -> Dict[str, Any]:
    """Get comprehensive build and system information."""
    ...

def list_available_modules() -> List[str]:
    """List all available QtForge modules."""
    ...

def test_connection() -> str:
    """Test function to verify bindings work."""
    ...

def get_system_info() -> Dict[str, Any]:
    """Get comprehensive system information."""
    ...

def create_metadata(name: str, description: str) -> Any:
    """Create basic plugin metadata."""
    ...

def get_help() -> str:
    """Get help information about QtForge Python bindings."""
    ...

# Re-export core classes for convenience
from .core import (
    PluginManager,
    IPlugin,
    PluginMetadata,
    PluginInfo,
    PluginLoadOptions,
    Version,
    PluginState,
    PluginCapability,
    PluginPriority,
    PluginLifecycleEvent,
)

# Re-export utility functions
from .utils import (
    utils_test,
    test_utils,
    create_version as utils_create_version,
    parse_version,
    create_error,
    register_qt_conversions,
)

class MessageBus:
    """Message bus for inter-plugin communication."""
    def __init__(self) -> None: ...

class SecurityManager:
    """Security manager for plugin security."""
    def __init__(self) -> None: ...
    def get_security_level(self) -> str: ...

class ConfigurationManager:
    """Configuration manager for plugin settings."""
    def __init__(self) -> None: ...

class CommunicationModule:
    """Communication module for message bus functionality."""
    MessageBus: type[MessageBus]

class SecurityModule:
    """Security module for plugin security management."""
    SecurityManager: type[SecurityManager]

class ManagersModule:
    """Managers module for various manager classes."""
    ConfigurationManager: type[ConfigurationManager]

# Enhanced core classes with comprehensive bindings
class PluginState:
    Unloaded: int
    Loaded: int
    Initialized: int
    Running: int
    Stopped: int
    Error: int

class PluginCapability:
    None_: int
    Service: int
    UI: int
    Network: int
    DataProcessor: int
    Scripting: int

class PluginPriority:
    Lowest: int
    Low: int
    Normal: int
    High: int
    Highest: int

class IPlugin:
    def name(self) -> str: ...
    def description(self) -> str: ...
    def version(self) -> str: ...
    def author(self) -> str: ...
    def id(self) -> str: ...
    def initialize(self) -> bool: ...
    def shutdown(self) -> bool: ...
    def state(self) -> int: ...
    def capabilities(self) -> int: ...
    def execute_command(self, command: str, params: Dict[str, Any]) -> Any: ...
    def available_commands(self) -> List[str]: ...

class PluginLoader:
    def __init__(self) -> None: ...
    def load_plugin(self, path: str) -> Optional[IPlugin]: ...
    def unload_plugin(self, plugin_id: str) -> bool: ...
    def is_plugin_loaded(self, plugin_id: str) -> bool: ...
    def get_loaded_plugins(self) -> List[str]: ...

class PluginRegistry:
    def __init__(self) -> None: ...
    def register_plugin(self, plugin: IPlugin) -> bool: ...
    def unregister_plugin(self, plugin_id: str) -> bool: ...
    def get_plugin(self, plugin_id: str) -> Optional[IPlugin]: ...
    def has_plugin(self, plugin_id: str) -> bool: ...
    def get_all_plugins(self) -> List[IPlugin]: ...
    def get_plugins_by_capability(self, capability: int) -> List[IPlugin]: ...
    def clear(self) -> None: ...
    def size(self) -> int: ...

# Orchestration classes
class StepStatus:
    Pending: int
    Running: int
    Completed: int
    Failed: int
    Skipped: int
    Cancelled: int
    Retrying: int

class ExecutionMode:
    Sequential: int
    Parallel: int
    Conditional: int
    Pipeline: int

class WorkflowStep:
    def __init__(self) -> None: ...
    id: str
    name: str
    description: str
    plugin_id: str
    service_name: str
    method_name: str
    parameters: Dict[str, Any]
    dependencies: List[str]
    max_retries: int
    critical: bool
    metadata: Dict[str, Any]

class StepResult:
    def __init__(self) -> None: ...
    step_id: str
    status: int
    result_data: Dict[str, Any]
    error_message: str
    retry_count: int
    def execution_time(self) -> int: ...

class Workflow:
    def __init__(self, id: str, name: str = "") -> None: ...
    def set_description(self, desc: str) -> 'Workflow': ...
    def set_execution_mode(self, mode: int) -> 'Workflow': ...
    def add_step(self, step: WorkflowStep) -> 'Workflow': ...
    def add_rollback_step(self, step: WorkflowStep) -> 'Workflow': ...
    def id(self) -> str: ...
    def name(self) -> str: ...
    def description(self) -> str: ...
    def execution_mode(self) -> int: ...

class PluginOrchestrator:
    def __init__(self) -> None: ...
    @staticmethod
    def create() -> 'PluginOrchestrator': ...
    def register_workflow(self, workflow: Workflow) -> bool: ...
    def unregister_workflow(self, workflow_id: str) -> bool: ...
    def has_workflow(self, workflow_id: str) -> bool: ...
    def get_workflow(self, workflow_id: str) -> Optional[Workflow]: ...
    def list_workflows(self) -> List[str]: ...
    def execute_workflow(self, workflow_id: str, params: Dict[str, Any] = {}) -> bool: ...
    def cancel_workflow(self, workflow_id: str) -> bool: ...
    def get_workflow_status(self, workflow_id: str) -> Dict[str, Any]: ...
    def get_workflow_results(self, workflow_id: str) -> List[StepResult]: ...
    def clear_workflows(self) -> None: ...

# New core classes from updated bindings
class DependencyNode:
    plugin_id: str
    dependencies: set[str]
    dependents: set[str]
    load_order: int

class IPluginDependencyResolver:
    def update_dependency_graph(self, registry: Any) -> bool: ...
    def get_dependency_graph(self) -> Dict[str, DependencyNode]: ...
    def get_load_order(self) -> List[str]: ...
    def can_unload_safely(self, plugin_id: str) -> bool: ...
    def has_circular_dependencies(self) -> bool: ...
    def get_dependents(self, plugin_id: str) -> List[str]: ...
    def get_dependencies(self, plugin_id: str) -> List[str]: ...
    def clear(self) -> None: ...

class PluginDependencyResolver(IPluginDependencyResolver):
    def __init__(self, parent: Optional[Any] = None) -> None: ...

class PluginLifecycleEvent:
    BeforeInitialize: int
    AfterInitialize: int
    BeforeShutdown: int
    AfterShutdown: int
    BeforePause: int
    AfterPause: int
    BeforeResume: int
    AfterResume: int
    StateChanged: int
    Error: int
    Timeout: int
    HealthCheck: int
    ResourceWarning: int
    DependencyChanged: int

class PluginLifecycleConfig:
    initialization_timeout: Any
    shutdown_timeout: Any
    pause_timeout: Any
    resume_timeout: Any
    health_check_interval: Any
    enable_graceful_shutdown: bool
    enable_health_monitoring: bool
    enable_resource_monitoring: bool
    auto_restart_on_failure: bool
    max_restart_attempts: int
    restart_delay: Any
    def to_json(self) -> Dict[str, Any]: ...
    @staticmethod
    def from_json(data: Dict[str, Any]) -> 'PluginLifecycleConfig': ...

class PluginLifecycleEventData:
    plugin_id: str
    event_type: int
    old_state: int
    new_state: int
    timestamp: Any
    message: str
    metadata: Dict[str, Any]
    error: Optional[Any]
    def to_json(self) -> Dict[str, Any]: ...
    @staticmethod
    def from_json(data: Dict[str, Any]) -> 'PluginLifecycleEventData': ...

class PluginHealthStatus:
    plugin_id: str
    is_healthy: bool
    last_check: Any
    response_time: Any
    metrics: Dict[str, Any]
    warnings: List[str]
    errors: List[str]
    def to_json(self) -> Dict[str, Any]: ...

class PluginLifecycleManager:
    def __init__(self, parent: Optional[Any] = None) -> None: ...
    def set_plugin_config(self, plugin_id: str, config: PluginLifecycleConfig) -> bool: ...
    def get_plugin_config(self, plugin_id: str) -> Optional[PluginLifecycleConfig]: ...
    def set_default_config(self, config: PluginLifecycleConfig) -> None: ...
    def get_default_config(self) -> PluginLifecycleConfig: ...
    def register_plugin(self, plugin: IPlugin, config: Optional[PluginLifecycleConfig] = None) -> bool: ...
    def unregister_plugin(self, plugin_id: str) -> bool: ...
    def is_plugin_registered(self, plugin_id: str) -> bool: ...
    def get_registered_plugins(self) -> List[str]: ...
    def initialize_plugin(self, plugin_id: str) -> bool: ...
    def shutdown_plugin(self, plugin_id: str, force: bool = False) -> bool: ...
    def pause_plugin(self, plugin_id: str) -> bool: ...
    def resume_plugin(self, plugin_id: str) -> bool: ...
    def restart_plugin(self, plugin_id: str) -> bool: ...

# Enhanced security classes
class SecurityLevel:
    None_: int
    Basic: int
    Standard: int
    High: int
    Maximum: int

class ValidationResult:
    is_valid: bool
    error_message: str
    warnings: List[str]
    security_level: int

class SecurityValidator:
    def __init__(self) -> None: ...
    def validate_file_integrity(self, file_path: str) -> ValidationResult: ...
    def validate_plugin_metadata(self, metadata: Dict[str, Any]) -> ValidationResult: ...
    def validate_plugin_dependencies(self, plugin_id: str, dependencies: List[str]) -> ValidationResult: ...
    def validate_plugin_permissions(self, plugin_id: str, permissions: List[str]) -> ValidationResult: ...

class SignatureVerifier:
    def __init__(self) -> None: ...
    def verify_plugin_signature(self, plugin_path: str) -> ValidationResult: ...
    def add_trusted_certificate(self, certificate_path: str) -> bool: ...
    def remove_trusted_certificate(self, certificate_id: str) -> bool: ...
    def get_trusted_certificates(self) -> List[str]: ...
    def clear_trusted_certificates(self) -> None: ...

class PermissionManager:
    def __init__(self) -> None: ...
    def grant_permission(self, plugin_id: str, permission: str) -> bool: ...
    def revoke_permission(self, plugin_id: str, permission: str) -> bool: ...
    def has_permission(self, plugin_id: str, permission: str) -> bool: ...
    def get_plugin_permissions(self, plugin_id: str) -> List[str]: ...

class SecurityPolicyEngine:
    def __init__(self) -> None: ...
    def evaluate_policy(self, plugin_id: str, context: Dict[str, Any]) -> ValidationResult: ...
    def add_policy_rule(self, rule_id: str, rule: str) -> bool: ...
    def remove_policy_rule(self, rule_id: str) -> bool: ...
    def get_policy_rules(self) -> Dict[str, str]: ...

# Convenience functions for all new modules
def create_plugin_loader() -> PluginLoader: ...
def create_plugin_registry() -> PluginRegistry: ...
def create_plugin_dependency_resolver() -> PluginDependencyResolver: ...
def create_plugin_lifecycle_manager() -> PluginLifecycleManager: ...
def create_message_bus() -> MessageBus: ...
def create_configuration_manager() -> ConfigurationManager: ...
def create_logging_manager() -> Any: ...
def create_resource_manager() -> Any: ...
def create_security_manager() -> SecurityManager: ...
def create_security_validator() -> SecurityValidator: ...
def create_signature_verifier() -> SignatureVerifier: ...
def create_permission_manager() -> PermissionManager: ...
def create_security_policy_engine() -> SecurityPolicyEngine: ...
def create_orchestrator() -> PluginOrchestrator: ...
def create_workflow(id: str, name: str = "") -> Workflow: ...
def create_workflow_step(id: str, plugin_id: str, method: str) -> WorkflowStep: ...
def create_hot_reload_manager() -> Any: ...
def create_metrics_collector() -> Any: ...
def setup_monitoring_system(metrics_interval: int = 5000) -> Tuple[Any, Any]: ...
def create_transaction_manager() -> Any: ...
def create_transaction_operation(op_id: str, plugin_id: str, type: int) -> Any: ...
def create_transaction_context(tx_id: str, isolation: int = 0) -> Any: ...
def execute_atomic_operation(manager: Any, operations: List[Any], isolation: int = 0) -> bool: ...
def create_composition_manager() -> Any: ...
def create_composition(id: str, name: str = "") -> Any: ...
def create_composition_binding(src_plugin: str, src_method: str, tgt_plugin: str, tgt_method: str) -> Any: ...
def create_pipeline_composition(id: str, plugin_ids: List[str]) -> Any: ...
def create_facade_composition(id: str, facade_plugin: str, backend_plugins: List[str]) -> Any: ...

def create_thread_pool(max_threads: int = 4) -> Any: ...
def create_thread_pool_manager() -> Any: ...

# Module definitions
from . import core
from . import utils

# Conditionally available modules (may not be present depending on build configuration)
communication: Optional[Any]
security: Optional[Any]
managers: Optional[Any]
orchestration: Optional[Any]
monitoring: Optional[Any]
threading: Optional[Any]
transactions: Optional[Any]
composition: Optional[Any]
