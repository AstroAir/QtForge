"""
QtForge Core Module Type Stubs

Type definitions for the qtforge.core submodule.
Contains core plugin system functionality.
"""

from typing import Any, Dict, List, Optional, Union, Callable
from enum import Enum
import datetime
from pathlib import Path

# Enums
class PluginState(Enum):
    Unloaded = ...
    Loaded = ...
    Initialized = ...
    Running = ...
    Stopped = ...
    Error = ...

class PluginCapability(Enum):
    None_ = ...
    Service = ...
    UI = ...
    Network = ...
    DataProcessor = ...
    Scripting = ...

class PluginPriority(Enum):
    Lowest = ...
    Low = ...
    Normal = ...
    High = ...
    Highest = ...

class PluginLifecycleEvent(Enum):
    BeforeInitialize = ...
    AfterInitialize = ...
    BeforeShutdown = ...
    AfterShutdown = ...
    BeforePause = ...
    AfterPause = ...
    BeforeResume = ...
    AfterResume = ...
    StateChanged = ...
    Error = ...
    Timeout = ...
    HealthCheck = ...
    ResourceWarning = ...

class PluginType(Enum):
    Native = ...
    Python = ...
    JavaScript = ...
    Lua = ...
    Remote = ...
    Composite = ...

class ServiceExecutionMode(Enum):
    MainThread = ...
    WorkerThread = ...
    ThreadPool = ...
    Async = ...
    Custom = ...

class ServiceState(Enum):
    Stopped = ...
    Starting = ...
    Running = ...
    Pausing = ...
    Paused = ...
    Resuming = ...
    Stopping = ...
    Error = ...
    Restarting = ...

class ServicePriority(Enum):
    Idle = ...
    Low = ...
    Normal = ...
    High = ...
    Critical = ...

class ServiceHealth(Enum):
    Unknown = ...
    Healthy = ...
    Warning = ...
    Critical = ...
    Unhealthy = ...

# Core Classes
class IPlugin:
    """Base plugin interface."""
    def name(self) -> str: ...
    def description(self) -> str: ...
    def version(self) -> str: ...
    def author(self) -> str: ...
    def id(self) -> str: ...
    def initialize(self) -> bool: ...
    def shutdown(self) -> None: ...
    def state(self) -> PluginState: ...
    def capabilities(self) -> PluginCapability: ...
    def execute_command(self, command: str, params: Dict[str, Any]) -> Any: ...
    def available_commands(self) -> List[str]: ...

class InterfaceCapability:
    """Interface capability descriptor."""
    name: str
    version: Any  # Version object
    metadata: Dict[str, Any]
    required: bool
    def to_json(self) -> Dict[str, Any]: ...
    @staticmethod
    def from_json(json_obj: Dict[str, Any]) -> 'InterfaceCapability': ...

class InterfaceDescriptor:
    """Interface descriptor for dynamic interfaces."""
    interface_id: str
    version: Any  # Version object
    description: str
    capabilities: List[InterfaceCapability]
    schema: Dict[str, Any]
    metadata: Dict[str, Any]
    def is_compatible_with(self, other: 'InterfaceDescriptor') -> bool: ...
    def to_json(self) -> Dict[str, Any]: ...
    @staticmethod
    def from_json(json_obj: Dict[str, Any]) -> 'InterfaceDescriptor': ...

class IAdvancedPlugin(IPlugin):
    """Advanced plugin interface with service contracts support."""
    def get_service_contracts(self) -> List[Any]: ...  # List[ServiceContract]
    def get_service_dependencies(self) -> List[Any]: ...
    def register_services(self) -> bool: ...
    def unregister_services(self) -> None: ...
    def call_service(self, service_name: str, method_name: str,
                    parameters: Dict[str, Any] = {}, timeout: int = 30000) -> Any: ...
    def validate_configuration(self, config: Dict[str, Any]) -> bool: ...
    def get_configuration_schema(self) -> Dict[str, Any]: ...
    def hot_reload(self) -> bool: ...
    def handle_dependency_change(self, dependency_id: str, new_state: PluginState) -> bool: ...

class IDynamicPlugin(IAdvancedPlugin):
    """Dynamic plugin interface with runtime adaptation."""
    def get_interface_descriptors(self) -> List[InterfaceDescriptor]: ...
    def supports_interface(self, interface_id: str, min_version: Any = None) -> bool: ...
    def get_interface_descriptor(self, interface_id: str) -> Optional[InterfaceDescriptor]: ...
    def adapt_to_interface(self, interface_id: str, target_version: Any) -> bool: ...
    def negotiate_capabilities(self, other_plugin_id: str,
                             requested_capabilities: List[InterfaceCapability]) -> List[InterfaceCapability]: ...
    def get_plugin_type(self) -> PluginType: ...
    def get_execution_context(self) -> Dict[str, Any]: ...
    def set_execution_context(self, context: Dict[str, Any]) -> None: ...

class IServicePlugin(IPlugin):
    """Service plugin interface for background services and long-running operations."""
    def start_service(self) -> None: ...
    def stop_service(self) -> None: ...
    def pause_service(self) -> None: ...
    def resume_service(self) -> None: ...
    def restart_service(self) -> None: ...
    def service_state(self) -> ServiceState: ...
    def service_health(self) -> ServiceHealth: ...
    def service_priority(self) -> ServicePriority: ...
    def execution_mode(self) -> ServiceExecutionMode: ...
    def service_info(self) -> Dict[str, Any]: ...
    def service_statistics(self) -> Dict[str, Any]: ...
    def set_service_priority(self, priority: ServicePriority) -> None: ...
    def set_execution_mode(self, mode: ServiceExecutionMode) -> None: ...

class PluginManager:
    """Central plugin management system."""
    def __init__(self) -> None: ...
    @staticmethod
    def create() -> 'PluginManager': ...
    def load_plugin(self, path: str) -> bool: ...
    def unload_plugin(self, plugin_id: str) -> bool: ...
    def get_plugin(self, plugin_id: str) -> Optional[IPlugin]: ...
    def has_plugin(self, plugin_id: str) -> bool: ...
    def get_all_plugins(self) -> List[IPlugin]: ...
    def get_plugins_by_capability(self, capability: PluginCapability) -> List[IPlugin]: ...
    def initialize_plugin(self, plugin_id: str) -> bool: ...
    def shutdown_plugin(self, plugin_id: str) -> bool: ...
    def get_plugin_count(self) -> int: ...
    def clear(self) -> None: ...

class PluginLoader:
    """Dynamic plugin loading system."""
    def __init__(self) -> None: ...
    def load_plugin(self, path: str) -> bool: ...
    def unload_plugin(self, plugin_id: str) -> bool: ...
    def is_plugin_loaded(self, plugin_id: str) -> bool: ...
    def get_loaded_plugins(self) -> List[str]: ...

class PluginRegistry:
    """Plugin registration and discovery system."""
    def __init__(self) -> None: ...
    def register_plugin(self, plugin: IPlugin) -> bool: ...
    def unregister_plugin(self, plugin_id: str) -> bool: ...
    def get_plugin(self, plugin_id: str) -> Optional[IPlugin]: ...
    def has_plugin(self, plugin_id: str) -> bool: ...
    def get_all_plugins(self) -> List[IPlugin]: ...
    def get_plugins_by_capability(self, capability: PluginCapability) -> List[IPlugin]: ...
    def clear(self) -> None: ...
    def size(self) -> int: ...

class DependencyNode:
    """Plugin dependency graph node."""
    plugin_id: str
    dependencies: set[str]
    dependents: set[str]
    load_order: int

class IPluginDependencyResolver:
    """Interface for plugin dependency resolution."""
    def update_dependency_graph(self, registry: Any) -> bool: ...
    def get_dependency_graph(self) -> Dict[str, DependencyNode]: ...
    def get_load_order(self) -> List[str]: ...
    def can_unload_safely(self, plugin_id: str) -> bool: ...
    def has_circular_dependencies(self) -> bool: ...
    def get_dependents(self, plugin_id: str) -> List[str]: ...
    def get_dependencies(self, plugin_id: str) -> List[str]: ...
    def clear(self) -> None: ...

class PluginDependencyResolver(IPluginDependencyResolver):
    """Plugin dependency resolver implementation."""
    def __init__(self, parent: Optional[Any] = None) -> None: ...

class PluginLifecycleConfig:
    """Plugin lifecycle configuration."""
    initialization_timeout: datetime.timedelta
    shutdown_timeout: datetime.timedelta
    pause_timeout: datetime.timedelta
    resume_timeout: datetime.timedelta
    health_check_interval: datetime.timedelta
    enable_graceful_shutdown: bool
    enable_health_monitoring: bool
    enable_resource_monitoring: bool
    auto_restart_on_failure: bool
    max_restart_attempts: int
    restart_delay: datetime.timedelta
    def to_json(self) -> Dict[str, Any]: ...
    @staticmethod
    def from_json(data: Dict[str, Any]) -> 'PluginLifecycleConfig': ...

class PluginLifecycleEventData:
    """Plugin lifecycle event data."""
    plugin_id: str
    event_type: PluginLifecycleEvent
    old_state: PluginState
    new_state: PluginState
    timestamp: datetime.datetime
    message: str
    metadata: Dict[str, Any]
    error: Optional[Any]
    def to_json(self) -> Dict[str, Any]: ...
    @staticmethod
    def from_json(data: Dict[str, Any]) -> 'PluginLifecycleEventData': ...

class PluginHealthStatus:
    """Plugin health status information."""
    plugin_id: str
    is_healthy: bool
    last_check: datetime.datetime
    response_time: datetime.timedelta
    metrics: Dict[str, Any]
    warnings: List[str]
    errors: List[str]
    def to_json(self) -> Dict[str, Any]: ...

class PluginLifecycleManager:
    """Plugin lifecycle management system."""
    def __init__(self, parent: Optional[Any] = None) -> None: ...
    def set_plugin_config(self, plugin_id: str, config: PluginLifecycleConfig) -> bool: ...
    def get_plugin_config(self, plugin_id: str) -> Optional[PluginLifecycleConfig]: ...
    def set_default_config(self, config: PluginLifecycleConfig) -> None: ...
    def get_default_config(self) -> PluginLifecycleConfig: ...
    def register_plugin(self, plugin: IPlugin, config: Optional[PluginLifecycleConfig] = None) -> bool: ...
    def unregister_plugin(self, plugin_id: str) -> bool: ...
    def is_plugin_registered(self, plugin_id: str) -> bool: ...
    def get_registered_plugins(self) -> List[str]: ...
    def initialize_plugin(self, plugin_id: str) -> bool: ...
    def shutdown_plugin(self, plugin_id: str, force: bool = False) -> bool: ...
    def pause_plugin(self, plugin_id: str) -> bool: ...
    def resume_plugin(self, plugin_id: str) -> bool: ...
    def restart_plugin(self, plugin_id: str) -> bool: ...
    def get_plugin_state(self, plugin_id: str) -> Optional[PluginState]: ...
    def can_transition_to_state(self, plugin_id: str, target_state: PluginState) -> bool: ...
    def get_plugin_state_history(self, plugin_id: str, max_entries: int = 100) -> List[PluginLifecycleEventData]: ...
    def enable_health_monitoring(self, plugin_id: str, callback: Optional[Callable] = None) -> bool: ...
    def disable_health_monitoring(self, plugin_id: str) -> bool: ...
    def check_plugin_health(self, plugin_id: str) -> Optional[PluginHealthStatus]: ...
    def get_plugin_health_status(self, plugin_id: str) -> Optional[PluginHealthStatus]: ...
    def register_event_callback(self, plugin_id: str, event_type: PluginLifecycleEvent, callback: Callable) -> str: ...
    def unregister_event_callback(self, callback_id: str) -> bool: ...
    def initialize_plugins(self, plugin_ids: List[str]) -> List[bool]: ...
    def shutdown_plugins(self, plugin_ids: List[str], force: bool = False) -> List[bool]: ...

# Factory Functions
def test_function() -> str:
    """Test function for verifying core module works."""
    ...

def get_version() -> str:
    """Get QtForge version string."""
    ...

def create_plugin_manager() -> PluginManager:
    """Create a new PluginManager instance."""
    ...

def create_plugin_loader() -> PluginLoader:
    """Create a new PluginLoader instance."""
    ...

def create_plugin_registry() -> PluginRegistry:
    """Create a new PluginRegistry instance."""
    ...

def create_plugin_dependency_resolver() -> PluginDependencyResolver:
    """Create a new PluginDependencyResolver instance."""
    ...

def create_plugin_lifecycle_manager() -> PluginLifecycleManager:
    """Create a new PluginLifecycleManager instance."""
    ...
