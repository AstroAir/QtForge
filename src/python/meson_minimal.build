# QtForge Python Bindings Build Configuration - Minimal Version

# Python bindings are only built if explicitly requested and dependencies are available
if not get_option('python_bindings') or not python3_dep.found() or not pybind11_dep.found()
  subdir_done()
endif

message('Building QtForge Python bindings (minimal version)')

# Python installation
python3 = import('python').find_installation('python3')

# Minimal Python binding sources - only working modules
python_binding_sources = [
  'qtforge_python_minimal.cpp',
  'core/core_bindings_minimal.cpp'
]

# Python binding dependencies (minimal)
python_binding_deps = [
  qtforge_core_dep,
  qt6_core_dep,
  python3_dep,
  pybind11_dep
]

# Python binding compile definitions
python_binding_definitions = [
  '-DQTPLUGIN_VERSION_MAJOR=@0@'.format(version_major),
  '-DQTPLUGIN_VERSION_MINOR=@0@'.format(version_minor),
  '-DQTPLUGIN_VERSION_PATCH=@0@'.format(version_patch),
  '-DQTFORGE_PYTHON_BINDINGS_MINIMAL'
]

# Create Python extension module (minimal)
qtforge_python_module_minimal = python3.extension_module('qtforge_minimal',
  python_binding_sources,
  include_directories: [inc_dir, src_inc_dir, include_directories('.')],
  dependencies: python_binding_deps,
  cpp_args: python_binding_definitions,
  install: false,  # Don't install minimal version
  subdir: 'qtforge_minimal'
)

# Generate minimal __init__.py
init_py_minimal_config = configuration_data()
init_py_minimal_config.set('VERSION_MAJOR', version_major)
init_py_minimal_config.set('VERSION_MINOR', version_minor)
init_py_minimal_config.set('VERSION_PATCH', version_patch)
init_py_minimal_config.set('VERSION_STRING', meson.project_version())

init_py_minimal_content = '''
"""
QtForge Python Bindings - Minimal Version

This is a minimal working version of the QtForge Python bindings
that includes only functionality known to compile and work correctly.

Version: @VERSION_STRING@
"""

__version__ = "@VERSION_STRING@"
__version_info__ = (@VERSION_MAJOR@, @VERSION_MINOR@, @VERSION_PATCH@)

# Import the minimal module
try:
    from .qtforge_minimal import *
    _BINDINGS_AVAILABLE = True
except ImportError as e:
    _BINDINGS_AVAILABLE = False
    _IMPORT_ERROR = str(e)
    
    # Provide fallback functions
    def version():
        return "@VERSION_STRING@"
    
    def version_info():
        return (@VERSION_MAJOR@, @VERSION_MINOR@, @VERSION_PATCH@)
    
    def test_function():
        return "QtForge minimal bindings - import failed: " + _IMPORT_ERROR
    
    def get_version():
        return "@VERSION_STRING@"
    
    def utils_test():
        return "Utils test - import failed: " + _IMPORT_ERROR

def is_available():
    """Check if bindings are available"""
    return _BINDINGS_AVAILABLE

def get_import_error():
    """Get import error if bindings failed to load"""
    return _IMPORT_ERROR if not _BINDINGS_AVAILABLE else None

# Minimal module structure
class _MinimalModule:
    """Minimal module placeholder"""
    def __getattr__(self, name):
        if not _BINDINGS_AVAILABLE:
            raise ImportError(f"QtForge bindings not available: {_IMPORT_ERROR}")
        raise AttributeError(f"Module has no attribute '{name}'")

# Create minimal submodules if main import failed
if not _BINDINGS_AVAILABLE:
    core = _MinimalModule()
    utils = _MinimalModule()
'''

init_py_minimal = configure_file(
  input: files(),
  output: '__init__.py',
  configuration: init_py_minimal_config,
  command: ['echo', init_py_minimal_content]
)

# Create dependency for minimal Python bindings
qtforge_python_minimal_dep = declare_dependency(
  dependencies: python_binding_deps
)
